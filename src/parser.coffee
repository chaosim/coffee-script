# ### begin original comment by jashkenas
# The CoffeeScript parser is generated by [Jison](http://github.com/zaach/jison)
# from this grammar file. Jison is a bottom-up parser generator, similar in
# style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.
# It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
# type grammars. To create the Jison parser, we list the pattern to match
# on the left-hand side, and the action to take (usually the creation of syntax
# tree nodes) on the right. As the parser runs, it
# shifts tokens from our token stream, from left to right, and
# [attempts to match](http://en.wikipedia.org/wiki/Bottom-up_parsing)
# the token sequence against the grammar below. When a match can be made, it
# reduces into the [nonterminal](http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
# (the enclosing name at the top), and we proceed from there.
#
# If you run the `cake build:parser` command, Jison constructs a parse table
# from our grammar and saves it into `lib/parser.js`.
# ### end original comment by jashkenas

# The only dependency is on the **Jison.Parser**.
# {Parser} = require 'jison' # the only dependency is not needed any more.

# Jison DSL
# ---------

# Since we're going to be wrapped in a function by Jison in any case, if our
# action immediately returns a value, we can optimize by removing the function
# wrapper and just returning the value directly.
unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

# Our handy DSL for Jison grammar generation, thanks to
# [Tim Caswell](http://github.com/creationix). For every rule in the grammar,
# we pass the pattern-defining string, the action to run, and extra options,
# optionally. If no action is specified, we simply pass the value of the
# previous nonterminal.
o = (patternString, action, options) ->
  patternString = patternString.replace /\s{2,}/g, ' '
  patternCount = patternString.split(' ').length
  return [patternString, '$$ = $1;', options] unless action
  action = if match = unwrap.exec action then match[1] else "(#{action}())"

  # All runtime functions we need are defined on "yy"
  action = action.replace /\bnew yy./g, '$&yy.'
  action = action.replace /\b(?:Block\.wrap|extend)\b/g, 'yy.$&'

  # Returns a function which adds location data to the first parameter passed
  # in, and returns the parameter.  If the parameter is not a node, it will
  # just be passed through unaffected.
  addLocationDataFn = (first, last) ->
    if not last
      "yy.addLocationDataFn(@#{first})"
    else
      "yy.addLocationDataFn(@#{first}, @#{last})"

  action = action.replace /LOC\(([0-9]*)\)/g, addLocationDataFn('$1')
  action = action.replace /LOC\(([0-9]*),\s*([0-9]*)\)/g, addLocationDataFn('$1', '$2')

  [patternString, "$$ = #{addLocationDataFn(1, patternCount)}(#{action});", options]

# some utilities used by the grammar grammar
# on succeed any matcher should not return a value which is not null or undefined, except the root symbol.

orp = (exps) -> (start) ->
  length = exps.length
  i = 0
  while i<length
    x = exps(start)
    if x? then return x

andp = (exps) -> (start) ->
  length = exps.length
  i = 0
  cursor = start
  while i<length
    x = exps(cursor)
    if not x? then return
  return x

notp = (exp) -> (start) ->
  x = exp(start)
  if not x? then return true
  return

char = (c) -> (start) ->
  if text[start]==c then cursor = start+1; return true

literal = (string) -> (start) ->
  len = string.length
  if text.slice(start,  stop = start+len)==string then cursor = stop; return true

keyword = (string) -> (start) ->
  len = string.length
  if text.slice(start, stop = start+len)==string and not text[stop2= stop+1].match /^[A-Za-z]/
    cursor = stop2; return true

spaces = (start) ->
  len = 0
  cursor = start
  while 1
    switch text[cursor]
      when ' ' then len++
      when '\t' then len += tabWidth
      else break
  return len

spaces1 = (start) ->
  len = 0
  cursor = start
  while 1
    switch text[cursor]
      when ' ' then len++
      when '\t' then len += tabWidth
      else break
  if len then return len

wrap = (item, left=spaces, right=spaces) -> (start) ->
  if left(start) and result = item(cursor) and right(cursor)
    return result

newyyValue = (item) -> (start) ->
  if x = item(start) then new yy.Value(x)

TERMINATOR = (start) -> wrap(';')
STATEMENT = (start) ->
  x = wrap(orp('break', 'continue'))
  if x then return new yy.Literal(x)
IDENTIFIER = (start) -> new yy.Literal $1
NUMBER = (start)-> new yy.Literal $1
STRING = (start) -> new yy.Literal $1
JS = (start) ->  new yy.Literal $1
REGEX = (start) -> new yy.Literal $1
DEBUGGER = (start) -> new yy.Literal $1
UNDEFINED = (start) -> new yy.Undefined
NULL = (start) -> new yy.Null
BOOL = (start) -> new yy.Bool $1
HERECOMMENT = (start) -> new yy.Comment $1

# Grammatical rules
# -----------------

# In all of the grammar that follow, you'll see the name of the nonterminal as
# the key to a list of alternative matches. With each match's action, the
# dollar-sign variables are provided by Jison as references to the value of
# their numeric position, so in this rule:
#
#     "Expression UNLESS Expression"
#
# `$1` would be the value of the first `Expression`, `$2` would be the token
# for the `UNLESS` terminal, and `$3` would be the value of the second
# `Expression`.

grammar =

# The **Root** is the top-level node in the syntax tree. Since we parse bottom-up,
# all parsing must end here.
  Root: (start) ->
    if cursor is textLength then return new yy.Block
    if result = grammar.Body(start) then return result
    result = grammar.Block(start)
    TERMINATOR(cursor)
    return result

  # Any list of statements and expressions, separated by line breaks or semicolons.
  Body: (start) ->
    lines = []
    x = grammar.Line(start)
    if x then lines.push(x)
    while 1
      x = grammar.Line(cursor)
      if x then lines.push(x)
      else TERMINATOR(cursor)
    yy.Block.wrap(lines)

  # Block and statements, which make up a line in a body.
  Line: orp(grammar.Expression, grammar.Statement)

  # Pure statements which cannot be expressions.
  Statement: orp(grammar.Return, grammar.Comment, STATEMENT)

  # All the different types of expressions in our language. The basic unit of
  # CoffeeScript is the **Expression** -- everything that can be an expression
  # is one. Blocks serve as the building blocks of many other grammar, making
  # them somewhat circular.
  Expression: orp(grammar.Value, grammar.Invocation, grammar.Code, grammar.Operation, grammar.Assign,
    grammar.If, grammar.Try, grammar.While, grammar.For, grammar.Switch, grammar.Class, grammar.Throw)

  # An indented block of expressions. Note that the [Rewriter](rewriter.html)
  # will convert some postfix forms into blocks for us, by adjusting the
  # token stream.
  Block: (start) ->
    if andp(INDENT, OUTDENT)(start) then new yy.Block
    else wrap(Body, INDENT, OUTDENT)(start)

  # A literal identifier, a variable name or property.
  Identifier: IDENTIFIER

  # Alphanumerics are separated from the other **Literal** matchers because
  # they can also serve as keys in object literals.
  AlphaNumeric: orp(NUMBER, STRING)

  # All of our immediate values. Generally these can be passed straight
  # through and printed to JavaScript.
  Literal: (start) ->  orp(AlphaNumeric, JS, REGEX, DEBUGGER, UNDEFINED, NULL, BOOL)

  # Assignment of a variable, property, or index to a value.
  Assign: (start) -> if left = grammar.Assignable(start) and wrap('=')(cursor)
      if exp = grammar.Expression(cursor) or\
         TERMINATOR(cursor) and exp = Expression(cursor) or
         INDENT(cursor) and exp = Expression and OUTDENT(cursor)
        new yy.Assign left, exp

  # Assignment when it happens within an object literal. The difference from
  # the ordinary **Assign** is that these allow numbers and strings as keys.
  AssignObj: (start) ->
    if x = grammar.Comment then return x
    left = ObjAssignable
    if not left then return
    if wrap(':')
      if exp = orp(grammar.Expression, wrap(grammar.Expression, INDENT, OUTDENT))
        new yy.Assign LOC(1)(new yy.Value(left)), exp, 'object'
      else new Error
    else new yy.Value left

  ObjAssignable: orp(grammar.Identifier, grammar.AlphaNumeric, grammar.ThisProperty)

  # A return statement from a function body.
  Return: (start) ->
    if RETURN(start)
      if $2 = grammar.Expression(cursor) then new yy.Return $2
      else new yy.Return

  # A block comment.
  Comment: HERECOMMENT

  # The **Code** node is the function literal. It's defined by an indented block
  # of **Block** preceded by a function arrow, with an optional parameter
  # list.
  Code: (start) ->
    if PARAM_START(start) and params = ParamList(cursor) and PARAM_END(cursor) \
      and funcGlyph = FuncGlyph(cursor) and body = Block(cursor)
      new yy.Code params, body, funcGlyph
    else if funcGlyph = FuncGlyph(cursor) and body = Block(cursor)
      new yy.Code [], body, funcGlyph

  # CoffeeScript has two different symbols for functions. `->` is for ordinary
  # functions, and `=>` is for functions bound to the current value of *this*.
  FuncGlyph: (start) ->
    if wrap('->')(start) then  'func'
    else if wrap('=>') then 'boundfunc'

  # An optional, trailing comma.
  OptComma: ->  wrap(orp(literal(''), ','))

  # The list of parameters that a function accepts can be of any length.
  ParamList: (start) ->
    result = []
    param = grammar.Param(start)
    if param then result.push(param)
    while 1
      if grammar.OptComma(cursor)
        if TERMINATOR(cursor)
          param = grammar.Param(cursor)
          if param then result.push(param); continue
        if INDENT(cursor)
          params = grammar.ParamList(cursor)
          for p in params then result.push(p)
          OUTDENT(cursor)
    result

  # A single parameter in a function definition can be ordinary, or a splat
  # that hoovers up the remaining arguments.
  Param: (start) ->
    v = grammar.ParamVar(start)
    if wrap('...') then new yy.Param v, null, on
    else if wrap('=') and exp = Expression(cursor) then  new yy.Param v, exp
    else new yy.Param v

  # Function Parameters
  ParamVar: orp(grammar.Identifier, grammar.ThisProperty, grammar.Array, grammar.Object)

  # A splat that occurs outside of a parameter list.
  Splat: (start) ->
    exp = grammar.Expression(start)
    wrap('...')(cursor)
    new yy.Splat exp

  # Variables and properties that can be assigned to.
  SimpleAssignable: (start) ->
   if name = grammar.Identifier(start) then  return new yy.Value name
   else if $1 = grammar.Value(start) and $2 = Accessor(cursor) then return $1.add $2
   else if $1 = grammar.Invocation(start) and grammar.Accessor(cursor) then new yy.Value $1, [].concat $2
   else return grammar.ThisProperty(start)

  # Everything that can be assigned to.
  Assignable: (start) ->
    grammar.SimpleAssignable(start) or\
    newyyValue(grammar.Array)(start) or\
    newyyValue(grammar.Object)(start)

  # The types of things that can be treated as values -- assigned to, invoked
  # as functions, indexed into, named as a class, etc.
  Value: (start) ->
    grammar.Assignable(start) or\
    newyyValue(grammar.Literal)(start) or\
    newyyValue(grammar.Parenthetical)(start) or\
    newyyValue(grammar.Range)(start) or\
    grammar.This(start)

  # The general group of accessors into an object, by property, by prototype
  # or by array index or slice.
  Accessor: (start) ->
    if wrap('.') and id = grammar.Identifier(cursor) then new yy.Access id
    else if wrap('?.') and id = grammar.Identifier(cursor) then new yy.Access id, 'soak'
    else if wrap('::') and id = grammar.Identifier(cursor)
      new[LOC(1)(new yy.Access new yy.Literal('prototype')), LOC(2)(new yy.Access id)]
    else if wrap('?::') and id = grammar.Identifier(cursor)
      [LOC(1)(new yy.Access new yy.Literal('prototype'), 'soak'), LOC(2)(new yy.Access id)]
    else grammar.Index(start)

  # Indexing into an object or array using bracket notation.
  Index: (start) ->
    if INDEX_START(start) and val = grammar.IndexValue(cursor) and INDEX_END(cursor) then val
    if INDEX_SOAK(cursor)  Index(cursor)
      yy.extend $2, soak : yes

  IndexValue: (start) ->
    if $1 = grammar.Expression(start) then new yy.Index $1
    else if $1 = grammar.Slice(start) then new yy.Slice $1

  # In CoffeeScript, an object literal is simply a list of assignments.
  Object: (start) ->
    if $1 = wrap('{')(start) and\
       $2 = grammar.AssignList(cursor) and\
       grammar.OptComma(cursor) and\
       wrap('}')(cursor)
      new yy.Obj $2, $1.generated

  # Assignment of properties within an object literal can be separated by
  # comma, as in JavaScript, or simply by newline.
  AssignList: (start) ->
    if wrap('[')(start) and wrap('')(cursor) and wrap(']')(cursor)  then []
    if grammar.AssignObj(start) then [$1]
    if grammar.AssignList(start) and wrap(',')(cursor) and grammar.AssignObj(cursor) then $1.concat $3
    grammar.AssignList(start) grammar.OptComma(cursor) TERMINATOR(cursor) AssignObj(cursor)  $1.concat $4
    AssignList(start) OptComma(cursor) INDENT(cursor) AssignList(cursor) OptComma(cursor) OUTDENT(cursor) $1.concat $4

  # Class definitions have optional bodies of prototype property assignments,
  # and optional references to the superclass.
  Class: (start) ->
    CLASS(start)  new yy.Class
    CLASS(start) Block(cursor)  new yy.Class null, null, $2
    CLASS(start) EXTENDS(cursor) Expression(cursor)  new yy.Class null, $3
    CLASS(start) EXTENDS(cursor) Expression(cursor) Block(cursor)  new yy.Class null, $3, $4
    CLASS(start) SimpleAssignable(cursor)  new yy.Class $2
    CLASS(start) SimpleAssignable(cursor) Block(cursor)  new yy.Class $2, null, $3
    CLASS(start) SimpleAssignable(cursor) EXTENDS(cursor) Expression(cursor)  new yy.Class $2, $4
    CLASS(start) SimpleAssignable(cursor) EXTENDS(cursor) Expression(cursor) Block(cursor)  new yy.Class $2, $4, $5

  # Ordinary function invocation, or a chained series of calls.
  Invocation: (start) ->
    Value(start) OptFuncExist(cursor) Arguments(cursor)  new yy.Call $1, $3, $2
    Invocation(start) OptFuncExist(cursor) Arguments(cursor)  new yy.Call $1, $3, $2
    SUPER(start)  new yy.Call 'super', [new yy.Splat new yy.Literal 'arguments']
    SUPER(start) Arguments(cursor)  new yy.Call 'super', $2

  # An optional existence check on a function.
  OptFuncExist: (start) ->
    if emptyword(start) then no
    if FUNC_EXIST(start) then yes

  # The list of arguments to a function call.
  Arguments: (start) ->
    if CALL_START(start) CALL_END(cursor) then []
    if CALL_START(start) ArgList(cursor) OptComma(cursor) CALL_END(cursor)
      $2

  # A reference to the *this* current object.
  This: (start) ->
    if THIS(start) then new yy.Value new yy.Literal 'this'
    if wrap('@')(start) then new yy.Value new yy.Literal 'this'

  # A reference to a property on *this*.
  ThisProperty: (start) ->
    if @(start) and Identifier(cursor) then 
      new yy.Value LOC(1)(new yy.Literal('this')), [LOC(2)(new yy.Access($2))], 'this'

  # The array literal.
  Array: (start) ->
    if wrap('[')(start) and wrap(']')(cursor) then new yy.Arr []
    else if wrap('[')(start) and ArgList(cursor) and OptComma(cursor) and wrap(']')(cursor)
      new yy.Arr $2

  # Inclusive and exclusive range dots.
  RangeDots: (start) ->
    if wrap('..')(start) then 'inclusive'
    else if wrap('...')(start) then 'exclusive'

  # The CoffeeScript range literal.
  Range: (start) ->
    if wrap('[')(start) and Expression(cursor) and RangeDots(cursor) and Expression(cursor) wrap(']')
      new yy.Range $2, $4, $3

  # Array slice literals.
  Slice: (start) ->
    if Expression(start) and RangeDots(cursor) and Expression(cursor)
      new yy.Range $1, $3, $2
    if Expression(start) and RangeDots(cursor)
      new yy.Range $1, null, $2
    if RangeDots(start) Expression(cursor) then new yy.Range null, $2, $1
    if RangeDots(start) then  new yy.Range null, null, $1

  # The **ArgList** is both the list of objects passed into a function call,
  # as well as the contents of an array literal
  # (i.e. comma-separated expressions). Newlines work as well.
  ArgList: (start) ->
    if Arg(start) then  [$1]
    if ArgList(start) and wrap(',') and Arg(cursor) then  $1.concat $3
    if ArgList(start) OptComma(cursor) TERMINATOR(cursor) Arg(cursor) then $1.concat $4
    if INDENT(start) ArgList(cursor) OptComma(cursor) OUTDENT(cursor) then $2
    if ArgList(start) OptComma(cursor) INDENT(cursor) ArgList(cursor) OptComma(cursor) OUTDENT(cursor)
      $1.concat $4

  # Valid arguments are Blocks or Splats.
  Arg:(start) -> Expression(start) or Splat(start)

  # Just simple, comma-separated, required arguments (no fancy syntax). We need
  # this to be separate from the **ArgList** for use in **Switch** blocks, where
  # having the newlines wouldn't make sense.
  SimpleArgs: (start) ->
    result = []
    exp = Expression(start)
    if exp then result.push(exp)
    while 1 then if wrap(',') and exp = Expression(cursor) then result.push(exp)

  # The variants of *try/catch/finally* exception handling blocks.
  Try: (start) ->
    test =  TRY(start) and Block(cursor)
    if test
      if Catch(cursor) and catch_ = Block(cursor)
        if FINALLY(cursor) and final = Block(cursor)
          then new yy.Try test, catch_[0], catch_[1], final
        else new yy.Try test, catch_[0], catch_[1]
      else if FINALLY(cursor) and final = Block(cursor)
        new yy.Try test, null, null, final
      else new yy.Try test

  # A catch clause names its error and runs a block of code.
  Catch: (start) ->
    if CATCH(start)
      if vari = Identifier(cursor) and  body = Block(cursor) then  [vari, body]
      if obj = Object(cursor)
        if body = Block(cursor) then [LOC(2)(new yy.Value(obj)), body]
      else if body = Block(cursor) then [null, body]

  # Throw an exception object.
  Throw: (start) ->
    if THROW(start) and Expression(cursor) then  new yy.Throw $2

  # Parenthetical expressions. Note that the **Parenthetical** is a **Value**,
  # not an **Expression**, so if you need to use an expression in a place
  # where only values are accepted, wrapping it in parentheses will always do
  # the trick.
  Parenthetical: (start) ->
    if wrap('(')(start)
      if body = Body(start)
        if wrap(')')(cursor) then new yy.Parens body
      if INDENT(start) and Body(cursor) and OUTDENT(cursor)
        if wrap(')')(cursor)  then new yy.Parens $3

  # The condition portion of a while loop.
  WhileSource: (start) ->
    if WHILE(start)
      if test = Expression(cursor)
        if WHEN(cursor) and value = Expression(cursor)
          new yy.While test, guard: value
        else new yy.While $2
    else if UNTIL(start)
      if test = Expression(cursor)
        if WHEN(cursor) and value = Expression(cursor)
          new yy.While $2, invert: true, guard: $4
        else new yy.While $2, invert: true

  # The while loop can either be normal, with a block of expressions to execute,
  # or postfix, with a single expression. There is no do..while.
  While: (start) ->
    if WhileSource(start) Block(cursor)  then $1.addBody $2
    else if Statement(start) and  WhileSource(cursor) then $2.addBody LOC(1) yy.Block.wrap([$1])
    else if Expression(start) and WhileSource(cursor) then $2.addBody LOC(1) yy.Block.wrap([$1])
    if body = Loop(start) then body

  Loop: (start) ->
    if LOOP(start)
      if body = Block(cursor) then new yy.While(LOC(1) new yy.Literal 'true').addBody body
      else if body = Expression(cursor)  new yy.While(LOC(1) new yy.Literal 'true').addBody LOC(2) Block.wrap [body]

  # Array, object, and range comprehensions, at the most generic level.
  # Comprehensions can either be normal, with a block of expressions to execute,
  # or postfix, with a single expression.
  For: (start) ->
    if action = Statement(start)  and test = ForBody(cursor) then new yy.For action, test
    else if action = Expression(start)  and test = ForBody(cursor) then new yy.For action, test
    else if test = ForBody(start) and  action = Block(cursor) then  new yy.For action, test

  ForBody: (start) ->
    if range = FOR Range(cursor) then source: LOC(2) new yy.Value(range)
    else if start = ForStart and src = ForSource(cursor)
      src.own = start.own; src.name = start[0]; src.index = start[1];
      src

  ForStart: (start) ->
    if FOR(start)
      if OWN(start)
        if vari = ForVariables(cursor) then vari.own = yes; vari
      else if vari = ForVariables(cursor) then vari



  # An array of all accepted values for a variable inside the loop.
  # This enables support for pattern matching.
  ForValue: (start) ->
    if id = Identifier(start) then id
    else if prop = ThisProperty(start) then prop
    else if Array(start) then  new yy.Value arr
    else if obj = Object(start) then  new yy.Value obj

  # An array or range comprehension has variables for the current element
  # and (optional) reference to the current index. Or, *key, value*, in the case
  # of object comprehensions.
  ForVariables: (start) ->
    if v = ForValue(start)
       if wrap(',')(cursor) and v3 = ForValue(cursor) then  [v1, v3]
       else [v]

  # The source of a comprehension is an array or object with an optional guard
  # clause. If it's an array comprehension, you can also choose to step through
  # in fixed-size increments.
  ForSource: (start) ->
    if FORIN(start) and source = Expression(cursor)
      if WHEN(cursor) and guard = Expression(cursor)
        if BY(cursor) and step = Expression(cursor)  source: source, guard: guard, step: step
        else source: source, guard: guard, object: yes
      else source: source
    if FOROF(start) and source = Expression(cursor)
      if WHEN(cursor) and guard = Expression(cursor)
        if BY(cursor) and step = Expression(cursor)  source: source, guard: guard, step: step
        else source: source, guard: guard, object: yes
      else source: source

  Switch: (start) ->
    if SWITCH(start)
      if INDENT(cursor)
        if whens = Whens(cursor)
          if ELSE(cursor) Block(cursor)   new yy.Switch null, whens, else_
          else new yy.Switch test, whens
        OUTDENT(cursor)
      else if test = Expression(cursor)
        if INDENT(cursor)
          if whens = Whens(cursor)
            if ELSE(cursor) Block(cursor)   new yy.Switch null, whens, else_
            else new yy.Switch test, whens
      OUTDENT(cursor)

  Whens: (start) ->
    result =[]
    while 1
      if LEADING_WHEN(start)
        if args = SimpleArgs(cursor) and action = Block(cursor) and may(TERMINATOR)(cursor)
          result.push([args, action])
        else return result

  # The most basic form of *if* is a condition and an action. The following
  # if-related grammar are broken up along these lines in order to avoid
  # ambiguity.
  IfBlock: (start) ->
    if IF(start) and test = Expression(cursor) and body = Block(cursor)
      new yy.If test, body, type: $1
    if IfBlock(start) and  ELSE(cursor) and IF(cursor) and Expression(cursor) and Block(cursor)
      $1.addElse new yy.If $4, $5, type: $3

  # The full complement of *if* expressions, including postfix one-liner
  # *if* and *unless*.
  If: (start) ->
    if if_ = IfBlock(start)
      if ELSE(cursor) and elseBody = Block(cursor)  then if_.addElse elseBody
      else if_
    if Statement(start)  and POST_IF(cursor) and Expression(cursor)
      new yy.If $3, LOC(1)(Block.wrap [$1]), type: $2, statement: true

# Arithmetic and logical operators, working on one or more operands.
# Here they are grouped by order of precedence. The actual precedence grammar
# are defined at the bottom of the page. It would be shorter if we could
# combine most of these grammar into a single generic *Operand OpSymbol Operand*
# -type rule, but in order to make the precedence binding possible, separate
# grammar are necessary.
Operation: (start) ->
  if op = UNARY(start) and exp = Expression(cursor) then new yy.Op op , exp
  else if wrap('-')(start) and exp = Expression(cursor)  then new yy.Op '-', exp, prec: 'UNARY'
  else if wrap('+')(start) and  exp = Expression(cursor) then new yy.Op '+', exp, prec: 'UNARY'

  else if wrap('--')(start) and SimpleAssignable(cursor)  then new yy.Op '--', $2
  else if wrap('++')(start) and SimpleAssignable(cursor) then  new yy.Op '++', $2
  else if SimpleAssignable(start) and wrap('--')(cursor)  then new yy.Op '--', $1, null, true
  else if SimpleAssignable(start) and wrap('++')(cursor)  then new yy.Op '++', $1, null, true

  # [The existential operator](http://jashkenas.github.com/coffee-script/#existence).
  else if Expression(start) and wrap('?')(cursor) then new yy.Existence $1

  else if Expression(start) and wrap('+')(cursor) and  Expression(cursor) then  new yy.Op '+' , $1, $3
  else if Expression(start) and -(cursor)  and Expression(cursor)  then new yy.Op '-' , $1, $3
  else if Expression(start) and MATH(cursor) and Expression(cursor)  then new yy.Op $2, $1, $3
  else if Expression(start) and SHIFT(cursor) and Expression(cursor)  then new yy.Op $2, $1, $3
  else if Expression(start) and COMPARE(cursor) and Expression  then new yy.Op $2, $1, $3
  else if Expression(start) and LOGIC(cursor) and Expression(cursor)  then new yy.Op $2, $1, $3
  else if Expression(start) and RELATION(cursor) and Expression(cursor)
    if $2.charAt(0) is '!' then new yy.Op($2[1..], $1, $3).invert()
    else new yy.Op $2, $1, $3

  else if SimpleAssignable(start) and COMPOUND_ASSIGN(cursor)
  else if Expression(cursor)  then new yy.Assign $1, $3, $2
  else if SimpleAssignable(start) and COMPOUND_ASSIGN(cursor)
  else if INDENT(cursor) and Expression(cursor) and OUTDENT(cursor)  then new yy.Assign $1, $4, $2
  else if SimpleAssignable(start) and COMPOUND_ASSIGN(cursor) and TERMINATOR(cursor)
  else if Expression(cursor)  then new yy.Assign $1, $4, $2
  else if SimpleAssignable(start) and EXTENDS(cursor) and Expression(cursor)  then new yy.Extends $1, $3
  else if Expression(start) and POST_IF(cursor) and Expression(cursor)
    new yy.If $3, LOC(1)(Block.wrap [$1]), type: $2, statement: true

# Precedence
# ----------

# Operators at the top of this list have higher precedence than the ones lower
# down. Following these grammar is what makes `2 + 3 * 4` parse as:
#
#     2 + (3 * 4)
#
# And not:
#
#     (2 + 3) * 4
operators = [
  ['left',      '.', '?.', '::', '?::']
  ['left',      'CALL_START', 'CALL_END']
  ['nonassoc',  '++', '--']
  ['left',      '?']
  ['right',     'UNARY']
  ['left',      'MATH']
  ['left',      '+', '-']
  ['left',      'SHIFT']
  ['left',      'RELATION']
  ['left',      'COMPARE']
  ['left',      'LOGIC']
  ['nonassoc',  'INDENT', 'OUTDENT']
  ['right',     '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS']
  ['right',     'FORIN', 'FOROF', 'BY', 'WHEN']
  ['right',     'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS']
  ['right',     'POST_IF']
]

# Wrapping Up
# -----------

# Finally, now that we have our **grammar** and our **operators**, we can create
# our **Jison.Parser**. We do this by processing all of our grammar, recording all
# terminals (every symbol which does not appear as the name of a rule above)
# as "tokens".
tokens = []
for name, alternatives of grammar
  grammar[name] = for alt in alternatives
    for token in alt[0].split ' '
      tokens.push token unless grammar[token]
    alt[1] = "return #{alt[1]}" if name is 'Root'
    alt

# Initialize the **Parser** with our list of terminal **tokens**, our **grammar**
# grammar, and the name of the root. Reverse the operators because Jison orders
# precedence from low to high, and we have it high to low
# (as in [Yacc](http://dinosaur.compilertools.net/yacc/index.html)).
exports.parser = new Parser
  tokens      : tokens.join ' '
  bnf         : grammar
  operators   : operators.reverse()
  startSymbol : 'Root'
