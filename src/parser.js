// Generated by CoffeeScript 1.6.2
(function() {
  var Continue, addLeftRecursiveCircles, addLeftRecursiveParentChildrens, andp, baseRules, char, cs, cursor, exp, generateLinenoColumn, grammar, identifier, keyword, lineColumnList, literal, memo, memorize, next, notp, operators, orp, parseCache, recAssignable, recFor, recIf, recInvocation, recValue, recWhile, recoAssign, recursive, result, setMemoTag, setMemorizeRules, setRecursiveRules, skipHeadSpaces, spaces, spaces1, spaces_, step, symbolToParentsMap, symbolToTagMap, tabWidth, tags, text, textLength, word_break, word_continue, word_return, wrap, wrapadd, wrapdec, wrapinc, wrapsub, yy, _i, _len, _ref, _spaces,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  _ref = require('./parserutil'), identifier = _ref.identifier, keyword = _ref.keyword;

  yy = require('../lib/coffee-script/nodes');

  text = '';

  textLength = 0;

  cursor = 0;

  tabWidth = 4;

  parseCache = {};

  symbolToTagMap = {};

  tags = {};

  symbolToParentsMap = {};

  baseRules = {};

  exports.parse = function(data, root, options) {
    var memoNames, o, start, symbol, _i, _len;

    o = options || {};
    if (typeof start === 'object') {
      start = 0;
      options = start;
    }
    text = data;
    textLength = text.length;
    cursor = o.start || 0;
    tabWidth = o.tabWidth || 4;
    parseCache = {};
    baseRules = {};
    symbolToParentsMap = {};
    memoNames = ['Expression', 'Body', 'Line', 'Block', 'Invocation', 'Value', 'Assignable', 'SimpleAssignable', 'For', 'If', 'Operation'];
    for (_i = 0, _len = memoNames.length; _i < _len; _i++) {
      symbol = memoNames[_i];
      setMemoTag(symbol);
    }
    addLeftRecursiveParentChildrens({
      Expression: ['Invocation', 'Value', 'Operation', 'Invocation', 'Assign', 'While', 'For'],
      Value: ['Assignable'],
      Assignable: ['SimpleAssignable'],
      SimpleAssignable: ['Value', 'Invocation'],
      Assign: ['Assignable'],
      Invocation: ['Value', 'Invocation'],
      For: ['Expression'],
      If: ['Expression'],
      Operation: ['Expression', 'SimpleAssignable']
    });
    setRecursiveRules(grammar);
    setMemorizeRules(grammar, ['Body', 'Line', 'Block', 'Statement']);
    generateLinenoColumn();
    return grammar.Root(0);
  };

  lineColumnList = [];

  generateLinenoColumn = function() {
    var c, column, i, lineno, _results;

    i = 0;
    lineno = column = 0;
    _results = [];
    while (i < textLength) {
      c = text[i];
      if (c === '\r') {
        lineColumnList[i++] = [lineno, column];
        if (text[i] === '\n') {
          lineColumnList[i++] = [lineno, column];
        }
        lineno++;
        _results.push(column = 0);
      } else if (c === '\n') {
        lineColumnList[i++] = [lineno, column];
        lineno++;
        _results.push(column = 0);
      } else if (c === '\t') {
        lineColumnList[i++] = [lineno, column];
        _results.push(column += tabWidth);
      } else {
        lineColumnList[i++] = [lineno, column];
        _results.push(column++);
      }
    }
    return _results;
  };

  setMemoTag = function(symbol) {
    var i, tag, _ref1;

    i = 1;
    while (1) {
      if (_ref1 = hasOwnProperty.call(tags, symbol.slice(0, i)), __indexOf.call(tags, _ref1) >= 0) {
        i++;
      } else {
        break;
      }
    }
    tag = symbol.slice(0, i);
    symbolToTagMap[symbol] = tag;
    return tags[tag] = true;
  };

  setMemorizeRules = function(grammar, symbols) {
    var symbol, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = symbols.length; _i < _len; _i++) {
      symbol = symbols[_i];
      baseRules[symbol] = grammar[symbol];
      _results.push(rules[symbol] = memorize(symbol));
    }
    return _results;
  };

  setRecursiveRules = function(grammar) {
    var map, symbol, _results;

    map = symbolToParentsMap;
    _results = [];
    for (symbol in map) {
      baseRules[symbol] = grammar[symbol];
      _results.push(rules[symbol] = recursive(symbol));
    }
    return _results;
  };

  addLeftRecursiveParentChildrens = function() {
    var children, list, map, parent, parentChildren, parentChildrens, symbol, _i, _len, _results;

    parentChildrens = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    map = symbolToParentsMap;
    _results = [];
    for (_i = 0, _len = parentChildrens.length; _i < _len; _i++) {
      parentChildren = parentChildrens[_i];
      _results.push((function() {
        var _results1;

        _results1 = [];
        for (parent in parentChildren) {
          children = parentChildren[parent];
          _results1.push((function() {
            var _j, _len1, _ref1, _results2;

            _results2 = [];
            for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
              symbol = children[_j];
              list = (_ref1 = map[symbol]) != null ? _ref1 : map[symbol] = [];
              if (parent !== symbol && __indexOf.call(list, parent) < 0) {
                _results2.push(list.push(parent));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  addLeftRecursiveCircles = function() {
    var circle, i, j, length, list, map, parent, recursiveCircles, symbol, _i, _len, _results;

    recursiveCircles = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    map = symbolToParentsMap;
    _results = [];
    for (_i = 0, _len = recursiveCircles.length; _i < _len; _i++) {
      circle = recursiveCircles[_i];
      i = 0;
      length = circle.length;
      _results.push((function() {
        var _ref1, _results1;

        _results1 = [];
        while (i < length) {
          if (i === length - 1) {
            j = 0;
          } else {
            j = i + 1;
          }
          symbol = circle[i];
          parent = circle[j];
          list = (_ref1 = map[symbol]) != null ? _ref1 : map[symbol] = [];
          if (parent !== symbol && __indexOf.call(list, parent) < 0) {
            list.push(parent);
          }
          _results1.push(i++);
        }
        return _results1;
      })());
    }
    return _results;
  };

  recursive = function(symbol) {
    var addParent, agenda, map, tag;

    map = symbolToParentsMap;
    tag = symbolToTagMap[symbol];
    agenda = [];
    addParent = function(parent) {
      var parents, _i, _len, _results;

      agenda.unshift(parent);
      parents = map[parent];
      if (parents) {
        _results = [];
        for (_i = 0, _len = parents.length; _i < _len; _i++) {
          parent = parents[_i];
          if (__indexOf.call(agenda, parent) < 0) {
            agenda.unshift(parent);
            _results.push(addParent(parent));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    addParent(symbol);
    return function(start) {
      var changed, hash, hash0, m, parent, result, rule, _i, _len, _ref1;

      hash0 = tag + start;
      m = parseCache[hash0];
      if (m) {
        cursor = m[1];
        return m[0];
      }
      while (agenda.length) {
        symbol = agenda.pop();
        hash = tag + start;
        m = parseCache[hash];
        if (!m) {
          m = parseCache[hash] = [void 0, start];
        }
        rule = baseRules[symbol];
        changed = false;
        while (1) {
          if ((result = rule(start)) && (result !== m[0] || cursor !== m[1])) {
            parseCache[hash] = m = [result, cursor];
            changed = true;
          } else {
            break;
          }
        }
        if (changed) {
          _ref1 = map[symbol];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            parent = _ref1[_i];
            if (__indexOf.call(agenda, parent) < 0) {
              agenda.push(parent);
            }
          }
        }
      }
      m = parseCache[hash0];
      cursor = m[1];
      return m[0];
    };
  };

  memorize = memorize = function(symbol) {
    var hash, rule, tag;

    tag = symbolToTagMap[symbol];
    rule = baseRules[symbol];
    hash = tag + start;
    return function(start) {
      var m, result;

      m = parseCache[hash];
      if (m) {
        cursor = m[1];
        return m[0];
      } else {
        result = rule(start);
        parseCache[hash] = [result, cursor];
        return result;
      }
    };
  };

  exports.memo = memo = function(symbol) {
    var tag;

    tag = symbolToTagMap[symbol];
    return function(start) {
      var m;

      m = parseCache[tag + start];
      if (m) {
        cursor = m[1];
        return m[0];
      }
    };
  };

  andp = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(start) {
      var exp, result, _i, _len;

      cursor = start;
      for (_i = 0, _len = exps.length; _i < _len; _i++) {
        exp = exps[_i];
        if (!(result = exp(cursor))) {
          return result;
        }
      }
      return result;
    };
  };

  orp = function() {
    var exps;

    exps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return function(start) {};
  };

  for (_i = 0, _len = exps.length; _i < _len; _i++) {
    exp = exps[_i];
    if (result = exp(start)) {
      return result;
    }
    return result;
  }

  notp = function(exp) {
    return function(start) {
      return !exp(start);
    };
  };

  next = function() {
    var c, column;

    c = text[cursor++];
    if (c === '\r') {
      if (text[cursor] === '\n') {
        c = text[cursor++];
      }
      lineno++;
      column = 0;
    } else if (c === '\n') {
      lineno++;
      column = 0;
    }
    return c;
  };

  step = function(n) {
    if (n == null) {
      n = 1;
    }
    cursor += n;
    return column += n;
  };

  char = function(c) {
    return function(start) {
      cursor = start;
      setlinecolumen();
      if (next() === c) {
        cursor = start + 1;
        return c;
      }
    };
  };

  literal = function(string) {
    return function(start) {
      var n, stop;

      n = string.length;
      if (text.slice(start, stop = start + n) === string) {
        cursor = stop;
        column += n;
        return true;
      }
    };
  };

  spaces = function(start) {
    var c, n;

    n = 0;
    cursor = start;
    while (1) {
      c = text[cursor];
      cursor++;
      if (c === ' ') {
        n++;
      } else if (c === '\t') {
        n += tabWidth;
      } else {
        break;
      }
    }
    column += n;
    return n + 1;
  };

  spaces1 = function(start) {
    var c, n;

    n = 0;
    cursor = start;
    while (1) {
      c = text[cursor];
      cursor++;
      if (c === ' ') {
        n++;
      } else if (c === '\t') {
        n += tabWidth;
      } else {
        break;
      }
    }
    if (n) {
      return column += n;
      return n;
    }
  };

  wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  exports.grammar = grammar = cs = {};

  cs.Root = function(start) {
    var body;

    skipHeadSpaces(start);
    if (cursor === textLength) {
      return new yy.Block;
    } else {
      return body = cs.Body(cursor);
    }
  };

  skipHeadSpaces = function(start) {
    var c;

    ({
      while1: (function() {
        var _results;

        _results = [];
        while (c = next()) {
          switch (c) {
            case ' ':
            case 't':
            case '\r':
            case '\n':
              continue;
            case '#':
              _results.push((function() {
                var _results1;

                _results1 = [];
                while (c = next()) {
                  if (c && c !== '\r' && c !== 'n') {
                    continue;
                  } else {
                    break;
                  }
                }
                return _results1;
              })());
              break;
            default:
              break while1;
              _results.push(void 0);
          }
        }
        return _results;
      })()
    });
    if (column !== 0) {
      throw new Error("Effect Code Line should at column 0, the begin of a line.");
    }
  };

  cs.Body = function(start) {
    var lines, x;

    lines = [];
    x = cs.Line(start);
    if (x) {
      lines.push(x);
    }
    while (1) {
      if (cs.TERMINATOR(cursor)) {
        if (x = cs.Line(cursor)) {
          lines.push(x);
        }
      } else {
        break;
      }
    }
    return yy.Block.wrap(lines);
  };

  cs.Line = function(start) {
    return cs.Statement(cursor) || cs.Expression(cursor);
  };

  cs.Statement = function(start) {
    return cs.Return(start) || cs.Comment(start) || cs.Break(start) || Continue(start);
  };

  cs.Return = function(start) {
    if (word_return(start) && spacesConcatLine(cursor)) {
      if (exp = cs.Expression(cursor)) {
        return new yy.Return(exp);
      } else {
        return new yy.Return;
      }
    }
  };

  cs.Comment = function(start) {
    return cs.HERECOMMENT(start);
  };

  cs.HERECOMMENT = function(start) {
    var c;

    cursor = start;
    c = next();
    if (c === '#') {
      if (text.slice(cursor, cursor + 2) === '##') {
        column += 2;
        cursor += 2;
        while (1) {
          c = next();
          if (c !== '#') {
            continue;
          }
          if (text.slice(cursor, cursor + 2) === '##') {
            return true;
          }
        }
      }
    } else {
      while (1) {
        if (c === '\n') {
          return true;
        }
      }
    }
  };

  cs.Break = function(start) {
    if (word_break(start) && spaces(cursor)) {
      return new yy.Literal('break');
    }
  };

  Continue = function(start) {
    if (word_continue(start) && spaces(cursor)) {
      return new yy.Literal('continue');
    }
  };

  word_return = literal('return');

  word_break = literal('break');

  word_continue = literal('continue');

  cs.Expression = function(start) {
    return recValue(start) || recOperation(start) || recInvocation(start) || recAssign(start) || recIf(start) || recWhile(start) || recFor(start) || cs.Switch(start) || cs.Throw(start) || cs.Class(start) || cs.Try(start) || cs.Code(start);
  };

  recValue = memo('Value');

  recInvocation = memo('Invocation');

  recoAssign = memo('Assign');

  recIf = memo('If');

  recWhile = memo('While');

  recFor = memo('For');

  cs.Block = function(start) {
    var body;

    if (INDENT(start)) {
      if (OUTDENT(cursor)) {
        return new yy.Block;
      } else if (body = cs.Body(cursor) && OUTDENT(cursor)) {
        return body;
      }
    }
  };

  cs.Identifier = function(start) {
    return cs.IDENTIFIER(start);
  };

  cs.Literal = function(start) {
    return cs.NUMBER(start) || cs.STRING(start) || cs.JS(start) || cs.REGEX(start) || cs.DEBUGGER(start) || cs.UNDEFINED(start) || cs.NULL(start) || cs.BOOL(start);
  };

  recAssignable = memo('Assignable');

  cs.Assign = function(start) {
    var left;

    if (left = recAssignable(start) && wrap('=')(cursor)) {
      if (exp = cs.Expression(cursor) || cs.TERMINATOR(cursor) && (exp = cs.Expression(cursor) || INDENT(cursor) && (exp = cs.Expression && OUTDENT(cursor)))) {
        return new yy.Assign(left, exp);
      }
    }
  };

  cs.AssignObj = function(start) {
    var left, x;

    if (x = cs.Comment) {
      return x;
    }
    if (left = cs.ObjAssignable(start)) {
      if (wrap(':')) {
        if (exp = cs.Expression(cursor) || INDENT(cursor) && (exp = cs.Expression(cursor) && OUTDENT(cursor))) {
          return new yy.Assign(LOC(1)(new yy.Value(left)), exp, 'object');
        }
      } else {
        return new yy.Value(left);
      }
    }
  };

  cs.ObjAssignable = function(start) {
    return cs.Identifier(start) || Number(start) || String(start) || cs.ThisProperty(start);
  };

  cs.Code = function(start) {
    var body, funcGlyph, params;

    if (PARAM_START(start) && (params = cs.ParamList(cursor) && PARAM_END(cursor) && (funcGlyph = cs.FuncGlyph(cursor) && (body = cs.Block(cursor))))) {
      return new yy.Code(params, body, funcGlyph);
    } else if (funcGlyph = cs.FuncGlyph(cursor) && (body = cs.Block(cursor))) {
      return new yy.Code([], body, funcGlyph);
    }
  };

  cs.FuncGlyph = function(start) {
    if (wrap('->')(start)) {
      return 'func';
    } else if (wrap('=>')) {
      return 'boundfunc';
    }
  };

  cs.OptComma = function(start) {
    spaces(start);
    if (char(',')) {
      spaces(cursor);
      [true];
    }
    return [false];
  };

  cs.ParamList = function(start) {
    var meetComma, p, param, params, _j, _len1;

    if (param = cs.Param(start)) {
      result = [param];
      while (1) {
        meetComma = cs.OptComma(cursor);
        if (cs.TERMINATOR(cursor) && (param = cs.Param(cursor))) {
          result.push(param);
        } else if (INDENT(cursor)) {
          params = cs.ParamList(cursor);
          for (_j = 0, _len1 = params.length; _j < _len1; _j++) {
            p = params[_j];
            result.push(p);
          }
          OUTDENT(cursor);
        } else if (meetComma[0] && (param = cs.Param(cursor))) {
          result.push(param);
        } else {
          break;
        }
      }
      return result;
    }
  };

  cs.Param = function(start) {
    var v;

    v = cs.ParamVar(start);
    if (wrap('...')(cursor)) {
      return new yy.Param(v, null, true);
    } else if (wrap('=')(cursor) && (exp = cs.Expression(cursor))) {
      return new yy.Param(v, exp);
    } else {
      return new yy.Param(v);
    }
  };

  cs.ParamVar = function(start) {
    return cs.Identifier(start) || cs.ThisProperty(start) || cs.Array(start) || cs.Object(start);
  };

  cs.Splat = function(start) {
    if (exp = cs.Expression(start) && wrap('...')(cursor)) {
      return new yy.Splat(exp);
    }
  };

  cs.SimpleAssignable = function(start) {
    var accessor, caller, name, thisProp, value;

    if (value = recValue(start) && (accessor = cs.Accessor(cursor))) {
      return value.add(accessor);
    } else if (caller = recInvocation(start) && (accessor = cs.Accessor(cursor))) {
      return new yy.Value(caller, [].concat(accessor));
    } else if (thisProp = cs.ThisProperty(start)) {
      return thisProp;
    } else if (name = cs.Identifier(start)) {
      return new yy.Value(name);
    }
  };

  cs.Assignable = function(start) {
    return recSimpleAssignable(start) || cs.newyyValue(cs.Array)(start) || cs.newyyValue(cs.Object)(start);
  };

  cs.Value = function(start) {
    return recAssignable(start) || cs.newyyValue(cs.Literal)(start) || cs.newyyValue(cs.Parenthetical)(start) || cs.newyyValue(cs.Range)(start) || cs.This(start);
  };

  cs.Accessor = function(start) {
    var id, index;

    if (wrap('.') && (id = cs.Identifier(cursor))) {
      return new yy.Access(id);
    } else if (wrap('?.') && (id = cs.Identifier(cursor))) {
      return new yy.Access(id, 'soak');
    } else if (wrap('::') && (id = cs.Identifier(cursor))) {
      return new [LOC(1)(new yy.Access(new yy.Literal('prototype'))), LOC(2)(new yy.Access(id))];
    } else if (wrap('?::') && (id = cs.Identifier(cursor))) {
      return [LOC(1)(new yy.Access(new yy.Literal('prototype'), 'soak')), LOC(2)(new yy.Access(id))];
    } else if (wrap('::')) {
      return new Access(new cs.Literal('prototype'));
    } else if (index = cs.Index(start)) {
      return index;
    }
  };

  cs.Index = function(start) {
    var val;

    if (INDEX_START(start) && (val = cs.IndexValue(cursor) && INDEX_END(cursor))) {
      val;
    }
    if (INDEX_SOAK(cursor) && cs.Index(cursor)) {
      return yy.extend($2, {
        soak: true
      });
    }
  };

  cs.IndexValue = function(start) {
    var slice, value;

    if (value = cs.Expression(start)) {
      return new yy.Index(value);
    } else if (slice = cs.Slice(start)) {
      return new yy.Slice(slice);
    }
  };

  cs.Object = function(start) {
    var assigns, leftBrace;

    if (leftBrace = wrap('{')(start)) {
      spaces(cursor);
      if (char('}')) {
        return new yy.Obj([], leftBrace.generated);
      } else if (assigns = cs.AssignList(cursor) && cs.OptComma(cursor) && wrap('}')(cursor)) {
        return new yy.Obj(assigns, leftBrace.generated);
      }
    }
  };

  cs.AssignList = function(start) {
    var assign, assigns, meetComma, x, _j, _len1;

    if (assign = cs.AssignObj(start)) {
      result = [assign];
      while (1) {
        meetComma = cs.OptComma(cursor);
        if (cs.TERMINATOR(cursor) && (assign = cs.AssignObj(cursor))) {
          result.push(assign);
        } else if (INDENT(cursor)) {
          assigns = cs.AssignList(cursor);
          for (_j = 0, _len1 = assigns.length; _j < _len1; _j++) {
            x = assigns[_j];
            result.push(x);
          }
          OUTDENT(cursor);
        } else if (meetComma[0] && (assign = cs.AssignObj(cursor))) {
          result.push(param);
        } else {
          break;
        }
      }
      return result;
    }
  };

  cs.Class = function(start) {
    var body, name, sup;

    if (CLASS(start)) {
      if (name = cs.SimpleAssignable(cursor)) {
        if (EXTENDS(cursor) && (sup = cs.Expression(cursor))) {
          if (body = cs.Block(cursor)) {
            return new yy.Class(name, sup, body);
          } else {
            return new yy.Class(name, sup);
          }
        } else if (body = cs.Block(cursor)) {
          return new yy.Class(name, null, body);
        } else {
          return new yy.Class(name);
        }
      } else {
        if (EXTENDS(cursor) && (sup = cs.Expression(cursor))) {
          if (body = cs.Block(cursor)) {
            return new yy.Class(null, sup, body);
          } else {
            return new yy.Class(null, sup);
          }
        } else if (body = cs.Block(cursor)) {
          return new yy.Class(null, null, body);
        } else {
          return new yy.Class;
        }
      }
    }
  };

  cs.Invocation = function(start) {
    var m1, m2;

    if (m1 = recValue(start) && cs.OptFuncExist(cursor) && cs.Arguments(cursor)) {
      new yy.Call($1, $3, $2);
    } else if (m2 = recInvocation(start) && cs.OptFuncExist(cursor) && cs.Arguments(cursor)) {
      new yy.Call($1, $3, $2);
    }
    if (!m1 && !m2) {
      if (SUPER(start)) {
        return new yy.Call('super', [new yy.Splat(new yy.Literal('arguments'))]);
      } else if (SUPER(start) && cs.Arguments(cursor)) {
        return new yy.Call('super', $2);
      }
    }
  };

  cs.OptFuncExist = function(start) {
    if (emptyword(start)) {
      false;
    }
    if (FUNC_EXIST(start)) {
      return true;
    }
  };

  cs.Arguments = function(start) {
    var args;

    if (CALL_START(start)) {
      if (args = cs.ArgList(cursor) && cs.OptComma(cursor)) {
        args;
      } else {
        result = [];
      }
      if (CALL_END(cursor)) {
        return result;
      }
    }
  };

  cs.This = function(start) {
    if (THIS(start)) {
      new yy.Value(new yy.Literal('this'));
    }
    if (wrap('')(start)) {
      return new yy.Value(new yy.Literal('this'));
    }
  };

  cs.ThisProperty = function(start) {
    if (wrap('')(start) && cs.Identifier(cursor)) {
      return new yy.Value(LOC(1)(new yy.Literal('this')), [LOC(2)(new yy.Access($2))], 'this');
    }
  };

  cs.Array = function(start) {
    if (wrap('[')(start)) {
      if (cs.ArgList(cursor) && cs.OptComma(cursor)) {
        result = new yy.Arr($2);
      } else {
        result = new yy.Arr([]);
      }
      if (wrap(']')(cursor)) {
        return result;
      }
    }
  };

  cs.RangeDots = function(start) {
    if (wrap('..')(start)) {
      return 'inclusive';
    } else if (wrap('...')(start)) {
      return 'exclusive';
    }
  };

  cs.Range = function(start) {
    if (wrap('[')(start) && cs.Expression(cursor) && cs.RangeDots(cursor) && cs.Expression(cursor)(wrap(']'))) {
      return new yy.Range($2, $4, $3);
    }
  };

  cs.Slice = function(start) {
    if (cs.Expression(start) && cs.RangeDots(cursor) && cs.Expression(cursor)) {
      new yy.Range($1, $3, $2);
    }
    if (cs.Expression(start) && cs.RangeDots(cursor)) {
      new yy.Range($1, null, $2);
    }
    if (cs.RangeDots(start) && cs.Expression(cursor)) {
      new yy.Range(null, $2, $1);
    }
    if (cs.RangeDots(start)) {
      return new yy.Range(null, null, $1);
    }
  };

  cs.ArgList = function(start) {
    if (cs.Arg(start)) {
      return [$1];
    } else if (cs.ArgList(start) && wrap(',') && cs.Arg(cursor)) {
      return $1.concat($3);
    } else if (cs.ArgList(start) && cs.OptComma(cursor) && cs.TERMINATOR(cursor) && cs.Arg(cursor)) {
      return $1.concat($4);
    } else if (INDENT(start) && cs.ArgList(cursor) && cs.OptComma(cursor) && OUTDENT(cursor)) {
      return $2;
    } else if (cs.ArgList(start) && cs.OptComma(cursor) && INDENT(cursor) && cs.ArgList(cursor) && cs.OptComma(cursor) && OUTDENT(cursor)) {
      return $1.concat($4);
    }
  };

  cs.Arg = function(start) {
    return cs.Expression(start) || cs.Splat(start);
  };

  cs.SimpleArgs = function(start) {
    if (exp = cs.Expression(start)) {
      result = [exp];
      while (1) {
        if (wrap(',')) {
          if (exp = cs.Expression(cursor)) {
            result.push(exp);
          } else {
            return;
          }
        }
      }
      return result;
    }
  };

  cs.Try = function(start) {
    var catch_, final, test;

    test = TRY(start) && cs.Block(cursor);
    if (test) {
      if (cs.Catch(cursor) && (catch_ = cs.Block(cursor))) {
        if (FINALLY(cursor) && (final = cs.Block(cursor))) {
          return new yy.Try(test, catch_[0], catch_[1], final);
        } else {
          return new yy.Try(test, catch_[0], catch_[1]);
        }
      } else if (FINALLY(cursor) && (final = cs.Block(cursor))) {
        return new yy.Try(test, null, null, final);
      } else {
        return new yy.Try(test);
      }
    }
  };

  cs.Catch = function(start) {
    var body, obj, vari;

    if (CATCH(start)) {
      if (vari = cs.Identifier(cursor) && (body = cs.Block(cursor))) {
        [vari, body];
      }
      if (obj = cs.Object(cursor)) {
        if (body = cs.Block(cursor)) {
          return [LOC(2)(new yy.Value(obj)), body];
        }
      } else if (body = cs.Block(cursor)) {
        return [null, body];
      }
    }
  };

  cs.Throw = function(start) {
    if (THROW(start) && cs.Expression(cursor)) {
      return new yy.Throw($2);
    }
  };

  cs.Parenthetical = function(start) {
    var body;

    if (wrap('(')(start)) {
      if (body = cs.Body(start)) {
        if (wrap(')')(cursor)) {
          new yy.Parens(body);
        }
      }
      if (INDENT(start) && cs.Body(cursor) && OUTDENT(cursor)) {
        if (wrap(')')(cursor)) {
          return new yy.Parens($3);
        }
      }
    }
  };

  cs.WhileSource = function(start) {
    var test, value;

    if (WHILE(start)) {
      if (test = cs.Expression(cursor)) {
        if (WHEN(cursor) && (value = cs.Expression(cursor))) {
          return new yy.While(test, {
            guard: value
          });
        } else {
          return new yy.While($2);
        }
      }
    } else if (UNTIL(start)) {
      if (test = cs.Expression(cursor)) {
        if (WHEN(cursor) && (value = cs.Expression(cursor))) {
          return new yy.While($2, {
            invert: true,
            guard: $4
          });
        } else {
          return new yy.While($2, {
            invert: true
          });
        }
      }
    }
  };

  cs.While = function(start) {
    var body;

    if (exp = recExpression(start) && cs.WhileSource(cursor)) {
      return $2.addBody(LOC(1)(yy.Block.wrap([$1])));
    }
    if (exp) {
      return retturn(exp);
    } else if (cs.WhileSource(start) && cs.Block(cursor)) {
      return $1.addBody($2);
    } else if (cs.Statement(start) && cs.WhileSource(cursor)) {
      return $2.addBody(LOC(1)(yy.Block.wrap([$1])));
    } else if (body = cs.Loop(start)) {
      return body;
    }
  };

  cs.Loop = function(start) {
    var body;

    if (LOOP(start)) {
      if (body = cs.Block(cursor)) {
        return new yy.While(LOC(1)(new yy.Literal('true'))).addBody(body);
      } else if (body = cs.Expression(cursor)) {
        return new yy.While(LOC(1)(new yy.Literal('true'))).addBody(LOC(2)(cs.Block.wrap([body])));
      }
    }
  };

  cs.For = function(start) {
    var action, test;

    if (action = recExpression(start) && (test = cs.ForBody(cursor))) {
      new yy.For(action, test);
    }
    if (action) {
      return action;
    }
    if (action = cs.Statement(start) && (test = cs.ForBody(cursor))) {
      return new yy.For(action, test);
    } else if (test = cs.ForBody(start) && (action = cs.Block(cursor))) {
      return new yy.For(action, test);
    }
  };

  cs.ForBody = function(start) {
    var range, src;

    if (range = FOR(start) && cs.Range(cursor)) {
      return {
        source: LOC(2)(new yy.Value(range))
      };
    } else if (start = cs.ForStart(start) && (src = cs.ForSource(cursor))) {
      src.own = start.own;
      src.name = start[0];
      src.index = start[1];
      return src;
    }
  };

  cs.ForStart = function(start) {
    var vari;

    if (FOR(start)) {
      if (OWN(cursor)) {
        if (vari = cs.ForVariables(cursor)) {
          vari.own = true;
          return vari;
        }
      } else if (vari = cs.ForVariables(cursor)) {
        return vari;
      }
    }
  };

  cs.ForValue = function(start) {
    var id, obj, prop;

    if (id = cs.Identifier(start)) {
      return id;
    } else if (prop = cs.ThisProperty(start)) {
      return prop;
    } else if (cs.Array(start)) {
      return new yy.Value(arr);
    } else if (obj = cs.Object(start)) {
      return new yy.Value(obj);
    }
  };

  cs.ForVariables = function(start) {
    var v, v3;

    if (v = cs.ForValue(start)) {
      if (wrap(',')(cursor) && (v3 = cs.ForValue(cursor))) {
        return [v1, v3];
      } else {
        return [v];
      }
    }
  };

  cs.ForSource = function(start) {
    var guard, source;

    if (FORIN(start) && (source = cs.Expression(cursor))) {
      if (WHEN(cursor) && (guard = cs.Expression(cursor))) {
        if (BY(cursor) && (step = cs.Expression(cursor))) {
          ({
            source: source,
            guard: guard,
            step: step
          });
        } else {
          ({
            source: source,
            guard: guard,
            object: true
          });
        }
      } else {
        ({
          source: source
        });
      }
    }
    if (FOROF(start) && (source = cs.Expression(cursor))) {
      if (WHEN(cursor) && (guard = cs.Expression(cursor))) {
        if (BY(cursor) && (step = cs.Expression(cursor))) {
          return {
            source: source,
            guard: guard,
            step: step
          };
        } else {
          return {
            source: source,
            guard: guard,
            object: true
          };
        }
      } else {
        return {
          source: source
        };
      }
    }
  };

  cs.Switch = function(start) {
    var test, whens;

    if (SWITCH(start)) {
      if (INDENT(cursor)) {
        if (whens = cs.Whens(cursor)) {
          if (ELSE(cursor)(cs.Block(cursor)(new yy.Switch(null, whens, else_)))) {

          } else {
            new yy.Switch(test, whens);
          }
        }
        OUTDENT(cursor);
      } else if (test = cs.Expression(cursor)) {
        if (INDENT(cursor)) {
          if (whens = cs.Whens(cursor)) {
            if (ELSE(cursor) && cs.Block(cursor)(new yy.Switch(null, whens, else_))) {

            } else {
              new yy.Switch(test, whens);
            }
          }
        }
      }
      return OUTDENT(cursor);
    }
  };

  cs.Whens = function(start) {
    var action, args;

    result = [];
    while (1) {
      if (LEADING_WHEN(start)) {
        if (args = cs.SimpleArgs(cursor) && (action = cs.Block(cursor) && may(cs.TERMINATOR)(cursor))) {
          result.push([args, action]);
        } else {
          return result;
        }
      }
    }
  };

  cs.IfBlock = function(start) {
    var body, test;

    if (IF(start) && (test = cs.Expression(cursor) && (body = cs.Block(cursor)))) {
      new yy.If(test, body, {
        type: $1
      });
    }
    if (cs.IfBlock(start) && ELSE(cursor) && IF(cursor) && cs.Expression(cursor) && cs.Block(cursor)) {
      return $1.addElse(new yy.If($4, $5, {
        type: $3
      }));
    }
  };

  cs.If = function(start) {
    var elseBody, if_;

    if (if_ = cs.IfBlock(start)) {
      if (ELSE(cursor) && (elseBody = cs.Block(cursor))) {
        if_.addElse(elseBody);
      } else {
        if_;
      }
    }
    if (cs.Statement(start) && POST_IF(cursor) && cs.Expression(cursor)) {
      return new yy.If($3, LOC(1)(cs.Block.wrap([$1])), {
        type: $2,
        statement: true
      });
    }
  };

  cs.Operation = function(start) {
    var m, op, simple;

    if (m = memo('Expression')(start)) {
      if (_spaces('?')(cursor)) {
        new yy.Existence($1);
      } else if (wrapadd(cursor) && cs.Expression(cursor)) {
        return new yy.Op('+', $1, $3);
      } else if (wrapsub(cursor) && cs.Expression(cursor)) {
        return new yy.Op('-', $1, $3);
      } else if (MATH(cursor) && cs.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (SHIFT(cursor) && cs.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (COMPARE(cursor) && cs.Expression) {
        return new yy.Op($2, $1, $3);
      } else if (LOGIC(cursor) && cs.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (RELATION(cursor) && cs.Expression(cursor)) {
        if ($2.charAt(0) === '!') {
          return new yy.Op($2.slice(1), $1, $3).invert();
        } else {
          return new yy.Op($2, $1, $3);
        }
      }
    } else if (simple = memo('SimpleAssignable')(start)) {
      if (COMPOUND_ASSIGN(cursor) && cs.Expression(start)) {
        return new yy.Assign($1, $3, $2);
      } else if (COMPOUND_ASSIGN(cursor) && INDENT(cursor) && cs.Expression(cursor) && OUTDENT(cursor)) {
        return new yy.Assign($1, $4, $2);
      } else if (COMPOUND_ASSIGN(cursor) && cs.TERMINATOR(cursor) && cs.Expression(cursor)) {
        return new yy.Assign($1, $4, $2);
      } else if (EXTENDS(cursor) && cs.Expression(cursor)) {
        new yy.Extends($1, $3);
      }
    }
    if (op = UNARY(start) && (exp = cs.Expression(cursor))) {
      return new yy.Op(op, exp);
    } else if (wrap('-')(start) && (exp = cs.Expression(cursor))) {
      return new yy.Op('-', exp, {
        prec: 'UNARY'
      });
    } else if (wrap('+')(start) && (exp = cs.Expression(cursor))) {
      return new yy.Op('+', exp, {
        prec: 'UNARY'
      });
    } else if (wrap('++')(start) && cs.SimpleAssignable(cursor)) {
      return new yy.Op('++', $2);
    } else if (wrapdec(start) && cs.SimpleAssignable(cursor)) {
      return new yy.Op('--', $2);
    } else if (cs.SimpleAssignable(start) && wrap('--')(cursor)) {
      return new yy.Op('--', $1, null, true);
    } else if (cs.SimpleAssignable(start) && wrap('++')(cursor)) {
      return new yy.Op('++', $1, null, true);
    }
  };

  wrapinc = wrap('++');

  wrapdec = wrap('--');

  wrapadd = wrap('+');

  wrapsub = wrap('-');

  _spaces = function(item) {
    return function(start) {
      return item(start) && spaces(cursor);
    };
  };

  spaces_ = function(item) {
    return function(start) {
      return spaces(start) && item(cursor);
    };
  };

  cs.newyyValue = function(item) {
    return function(start) {
      var x;

      if (x = item(start)) {
        return new yy.Value(x);
      }
    };
  };

  cs.TERMINATOR = function(start) {
    var c, column;

    cursor = start;
    while (1) {
      c = next;
      if (c === ' ' || c === ';' || c === '\t') {
        continue;
      } else if (c === '\\') {
        if (text[cursor + 1] === '\r' && text[cursor + 2] === '\n') {
          cursor += 3;
          lineno++;
          column = 0;
        } else if (text[cursor + 1] === '\n') {
          cursor += 2;
          lineno++;
          column = 0;
        } else {
          new ParseError(lineno, column, "meet a line concatenation symbol ('\\') which is not at the end of line.");
        }
      } else {
        break;
      }
    }
    return true;
  };

  cs.IDENTIFIER = function(start) {
    var id;

    if (id = identifier(start)) {
      return new yy.Literal(id);
    }
  };

  cs.NUMBER = function(start) {
    return new yy.Literal($1);
  };

  cs.STRING = function(start) {
    return new yy.Literal($1);
  };

  cs.JS = function(start) {
    return new yy.Literal($1);
  };

  cs.REGEX = function(start) {
    return new yy.Literal($1);
  };

  cs.DEBUGGER = function(start) {
    return new yy.Literal($1);
  };

  cs.UNDEFINED = function(start) {
    return new yy.Undefined;
  };

  cs.NULL = function(start) {
    return new yy.Null;
  };

  cs.BOOL = function(start) {
    return new yy.Bool($1);
  };

  cs.HERECOMMENT = function(start) {
    return new yy.Comment($1);
  };

  operators = [['left', '.', '?.', '::', '?::'], ['left', 'CALL_START', 'CALL_END'], ['nonassoc', '++', '--'], ['left', '?'], ['right', 'UNARY'], ['left', 'MATH'], ['left', '+', '-'], ['left', 'SHIFT'], ['left', 'RELATION'], ['left', 'COMPARE'], ['left', 'LOGIC'], ['nonassoc', 'INDENT', 'OUTDENT'], ['right', '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS'], ['right', 'FORIN', 'FOROF', 'BY', 'WHEN'], ['right', 'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS'], ['right', 'POST_IF']];

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
