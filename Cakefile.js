// Generated by CoffeeScript 1.6.2
(function() {
  var CoffeeScript, bold, build, exec, fs, green, header, helpers, log, path, red, reset, run, runTests, spawn, _ref;

  fs = require('fs');

  path = require('path');

  CoffeeScript = require('./lib/coffee-script');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  helpers = require('./lib/coffee-script/helpers');

  bold = red = green = reset = '';

  if (!process.env.NODE_DISABLE_COLORS) {
    bold = '\x1B[0;1m';
    red = '\x1B[0;31m';
    green = '\x1B[0;32m';
    reset = '\x1B[0m';
  }

  header = "/**\n * CoffeeScript Compiler v" + CoffeeScript.VERSION + "\n * http://coffeescript.org\n *\n * Copyright 2011, Jeremy Ashkenas\n * Released under the MIT License\n */";

  build = function(cb) {
    var file, files;

    files = fs.readdirSync('src');
    files = (function() {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.match(/\.(lit)?coffee$/)) {
          _results.push('src/' + file);
        }
      }
      return _results;
    })();
    return run(['-c', '-o', 'lib/coffee-script'].concat(files), cb);
  };

  run = function(args, cb) {
    var proc;

    proc = spawn('node', ['bin/coffee'].concat(args));
    proc.stderr.on('data', function(buffer) {
      return console.log(buffer.toString());
    });
    return proc.on('exit', function(status) {
      if (status !== 0) {
        process.exit(1);
      }
      if (typeof cb === 'function') {
        return cb();
      }
    });
  };

  log = function(message, color, explanation) {
    return console.log(color + message + reset + ' ' + (explanation || ''));
  };

  option('-p', '--prefix [DIR]', 'set the installation prefix for `cake install`');

  task('install', 'install CoffeeScript into /usr/local (or --prefix)', function(options) {
    var base, bin, lib, node;

    base = options.prefix || '/usr/local';
    lib = "" + base + "/lib/coffee-script";
    bin = "" + base + "/bin";
    node = "~/.node_libraries/coffee-script";
    console.log("Installing CoffeeScript to " + lib);
    console.log("Linking to " + node);
    console.log("Linking 'coffee' to " + bin + "/coffee");
    return exec(["mkdir -p " + lib + " " + bin, "cp -rf bin lib LICENSE README package.json src " + lib, "ln -sfn " + lib + "/bin/coffee " + bin + "/coffee", "ln -sfn " + lib + "/bin/cake " + bin + "/cake", "mkdir -p ~/.node_libraries", "ln -sfn " + lib + "/lib/coffee-script " + node].join(' && '), function(err, stdout, stderr) {
      if (err) {
        return console.log(stderr.trim());
      } else {
        return log('done', green);
      }
    });
  });

  task('build', 'build the CoffeeScript language from source', build);

  task('build:full', 'rebuild the source twice, and run the tests', function() {
    return build(function() {
      return build(function() {
        var csDir, csPath, mod;

        csPath = './lib/coffee-script';
        csDir = path.dirname(require.resolve(csPath));
        for (mod in require.cache) {
          if (csDir === mod.slice(0, csDir.length)) {
            delete require.cache[mod];
          }
        }
        if (!runTests(require(csPath))) {
          return process.exit(1);
        }
      });
    });
  });

  task('build:parser', 'rebuild the Jison parser (run build first)', function() {
    var parser;

    helpers.extend(global, require('util'));
    require('jison');
    parser = require('./lib/coffee-script/grammar').parser;
    return fs.writeFile('lib/coffee-script/parser.js', parser.generate());
  });

  task('build:ultraviolet', 'build and install the Ultraviolet syntax highlighter', function() {
    return exec('plist2syntax ../coffee-script-tmbundle/Syntaxes/CoffeeScript.tmLanguage', function(err) {
      if (err) {
        throw err;
      }
      return exec('sudo mv coffeescript.yaml /usr/local/lib/ruby/gems/1.8/gems/ultraviolet-0.10.2/syntax/coffeescript.syntax');
    });
  });

  task('build:browser', 'rebuild the merged script for inclusion in the browser', function() {
    var code, name, _i, _len, _ref1;

    code = '';
    _ref1 = ['helpers', 'rewriter', 'lexer', 'parser', 'scope', 'nodes', 'sourcemap', 'coffee-script', 'browser'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      code += "require['./" + name + "'] = (function() {\n  var exports = {}, module = {exports: exports};\n  " + (fs.readFileSync("lib/coffee-script/" + name + ".js")) + "\n  return module.exports;\n})();";
    }
    code = "(function(root) {\n  var CoffeeScript = function() {\n    function require(path){ return require[path]; }\n    " + code + "\n    return require['./coffee-script'];\n  }();\n\n  if (typeof define === 'function' && define.amd) {\n    define(function() { return CoffeeScript; });\n  } else {\n    root.CoffeeScript = CoffeeScript;\n  }\n}(this));";
    if (process.env.MINIFY !== 'false') {
      code = require('uglify-js').minify(code, {
        fromString: true
      }).code;
    }
    fs.writeFileSync('extras/coffee-script.js', header + '\n' + code);
    console.log("built ... running browser tests:");
    return invoke('test:browser');
  });

  task('doc:site', 'watch and continually rebuild the documentation for the website', function() {
    return exec('rake doc', function(err) {
      if (err) {
        throw err;
      }
    });
  });

  task('doc:source', 'rebuild the internal documentation', function() {
    return exec('docco src/*.*coffee && cp -rf docs documentation && rm -r docs', function(err) {
      if (err) {
        throw err;
      }
    });
  });

  task('doc:underscore', 'rebuild the Underscore.coffee documentation page', function() {
    return exec('docco examples/underscore.coffee && cp -rf docs documentation && rm -r docs', function(err) {
      if (err) {
        throw err;
      }
    });
  });

  task('bench', 'quick benchmark of compilation time', function() {
    var Rewriter, coffee, fmt, js, litcoffee, littokens, nodes, now, sources, time, tokens, total;

    Rewriter = require('./lib/coffee-script/rewriter').Rewriter;
    sources = ['coffee-script', 'grammar', 'helpers', 'lexer', 'nodes', 'rewriter'];
    coffee = sources.map(function(name) {
      return fs.readFileSync("src/" + name + ".coffee");
    }).join('\n');
    litcoffee = fs.readFileSync("src/scope.litcoffee").toString();
    fmt = function(ms) {
      return " " + bold + (("   " + ms).slice(-4)) + reset + " ms";
    };
    total = 0;
    now = Date.now();
    time = function() {
      var ms;

      total += ms = -(now - (now = Date.now()));
      return fmt(ms);
    };
    tokens = CoffeeScript.tokens(coffee, {
      rewrite: false
    });
    littokens = CoffeeScript.tokens(litcoffee, {
      rewrite: false,
      literate: true
    });
    tokens = tokens.concat(littokens);
    console.log("Lex    " + (time()) + " (" + tokens.length + " tokens)");
    tokens = new Rewriter().rewrite(tokens);
    console.log("Rewrite" + (time()) + " (" + tokens.length + " tokens)");
    nodes = CoffeeScript.nodes(tokens);
    console.log("Parse  " + (time()));
    js = nodes.compile({
      bare: true
    });
    console.log("Compile" + (time()) + " (" + js.length + " chars)");
    return console.log("total  " + (fmt(total)));
  });

  runTests = function(CoffeeScript) {
    var arrayEgal, code, currentFile, egal, error, failures, file, filename, files, func, literate, name, passedTests, startTime, _i, _len, _ref1;

    startTime = Date.now();
    currentFile = null;
    passedTests = 0;
    failures = [];
    _ref1 = require('assert');
    for (name in _ref1) {
      func = _ref1[name];
      global[name] = func;
    }
    global.CoffeeScript = CoffeeScript;
    global.Repl = require('./lib/coffee-script/repl');
    global.test = function(description, fn) {
      var e;

      try {
        fn.test = {
          description: description,
          currentFile: currentFile
        };
        fn.call(fn);
        return ++passedTests;
      } catch (_error) {
        e = _error;
        return failures.push({
          filename: currentFile,
          error: e,
          description: description != null ? description : void 0,
          source: fn.toString != null ? fn.toString() : void 0
        });
      }
    };
    egal = function(a, b) {
      if (a === b) {
        return a !== 0 || 1 / a === 1 / b;
      } else {
        return a !== a && b !== b;
      }
    };
    arrayEgal = function(a, b) {
      var el, idx, _i, _len;

      if (egal(a, b)) {
        return true;
      } else if (a instanceof Array && b instanceof Array) {
        if (a.length !== b.length) {
          return false;
        }
        for (idx = _i = 0, _len = a.length; _i < _len; idx = ++_i) {
          el = a[idx];
          if (!arrayEgal(el, b[idx])) {
            return false;
          }
        }
        return true;
      }
    };
    global.eq = function(a, b, msg) {
      return ok(egal(a, b), msg != null ? msg : "Expected " + a + " to equal " + b);
    };
    global.arrayEq = function(a, b, msg) {
      return ok(arrayEgal(a, b), msg != null ? msg : "Expected " + a + " to deep equal " + b);
    };
    process.on('exit', function() {
      var description, error, fail, filename, message, source, time, _i, _len;

      time = ((Date.now() - startTime) / 1000).toFixed(2);
      message = "passed " + passedTests + " tests in " + time + " seconds" + reset;
      if (!failures.length) {
        return log(message, green);
      }
      log("failed " + failures.length + " and " + message, red);
      for (_i = 0, _len = failures.length; _i < _len; _i++) {
        fail = failures[_i];
        error = fail.error, filename = fail.filename, description = fail.description, source = fail.source;
        console.log('');
        if (description) {
          log("  " + description, red);
        }
        log("  " + error.stack, red);
        if (source) {
          console.log("  " + source);
        }
      }
    });
    files = fs.readdirSync('test');
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (!(helpers.isCoffee(file))) {
        continue;
      }
      literate = helpers.isLiterate(file);
      currentFile = filename = path.join('test', file);
      code = fs.readFileSync(filename);
      try {
        CoffeeScript.run(code.toString(), {
          filename: filename,
          literate: literate
        });
      } catch (_error) {
        error = _error;
        failures.push({
          filename: filename,
          error: error
        });
      }
    }
    return !failures.length;
  };

  task('test', 'run the CoffeeScript language test suite', function() {
    return runTests(CoffeeScript);
  });

  task('test:browser', 'run the test suite against the merged browser script', function() {
    var result, source;

    source = fs.readFileSync('extras/coffee-script.js', 'utf-8');
    result = {};
    global.testingBrowser = true;
    (function() {
      return eval(source);
    }).call(result);
    return runTests(result.CoffeeScript);
  });

}).call(this);

/*
//@ sourceMappingURL=Cakefile.map
*/
