// Generated by CoffeeScript 1.6.2
(function() {
  var Parser, char, i, identifier, keyword, literal, operators, spaces, spaces1, w, wordNumMap, wrap, _i, _len, _ref;

  char = function(c) {
    return function(start) {
      var cursor;

      if (text[start] === c) {
        cursor = start + 1;
        return true;
      }
    };
  };

  literal = function(string) {
    return function(start) {
      var cursor, len, stop;

      len = string.length;
      if (text.slice(start, stop = start + len) === string) {
        cursor = stop;
        return true;
      }
    };
  };

  keyword = function(string) {
    return function(start) {
      var cursor, len, stop, stop2;

      len = string.length;
      if (text.slice(start, stop = start + len) === string && !text[stop2 = stop + 1].match(/^[A-Za-z]/)) {
        cursor = stop2;
        return true;
      }
    };
  };

  spaces = function(start) {
    var cursor, len;

    len = 0;
    cursor = start;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    return len;
  };

  spaces1 = function(start) {
    var cursor, len;

    len = 0;
    cursor = start;
    while (1) {
      switch (text[cursor]) {
        case ' ':
          len++;
          break;
        case '\t':
          len += tabWidth;
          break;
        default:
          break;
      }
    }
    if (len) {
      return len;
    }
  };

  wrap = function(item, left, right) {
    if (left == null) {
      left = spaces;
    }
    if (right == null) {
      right = spaces;
    }
    return function(start) {
      var result;

      if (left(start) && (result = item(cursor) && right(cursor))) {
        return result;
      }
    };
  };

  identifier = function(start) {
    var cursor, stop, w;

    cursor = start;
    switch (text[cursor]) {
      case '$':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
        while (1) {
          switch (text[cursor]) {
            case '$':
            case '_':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
              cursor++;
          }
        }
    }
    stop = cursor;
    w = keyword(start);
    if (w && cursor === stop) {
      return void 0;
    } else {
      return text.slice(start, cursor);
    }
  };

  wordNumMap = {};

  i = 1;

  _ref = ['__bind', '__extends', '__hasProp', '__indexOf', '__slice', 'break', 'by', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'loop', 'native', 'new', 'null', 'of', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'then', 'this', 'throw', 'true', 'try', 'typeof', 'undefined', 'unless', 'until', 'var', 'void', 'when', 'while', 'with', 'yield'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    w = _ref[_i];
    wordNumMap[w] = i++;
  }

  keyword = function(start) {
    var cursor;

    cursor = start;
    switch (text[cursor++]) {
      case '_':
        if (text[cursor++] === '_') {
          switch (text[cursor++]) {
            case 'b':
              if (text.slice(cursor, cursor += 3) === 'ind') {
                return '__bind';
              }
              break;
            case 'e':
              if (text.slice(cursor, cursor += 6) === 'xtends') {
                return '__extends';
              }
              break;
            case 'h':
              if (text.slice(cursor, cursor += 6) === 'asProp') {
                return '__hasProp';
              }
              break;
            case 'i':
              if (text.slice(cursor, cursor += 6) === 'ndexOf') {
                return '__indexOf';
              }
              break;
            case 's':
              if (text.slice(cursor, cursor += 4) === 'lice') {
                return '__slice';
              }
          }
        }
        break;
      case 'b':
        switch (text[cursor++]) {
          case 'r':
            if (text.slice(cursor, cursor += 3) === 'eak') {
              return 'break';
            }
            break;
          case 'y':
            return 'by';
        }
        break;
      case 'c':
        switch (text[cursor++]) {
          case 'a':
            switch (text[cursor++]) {
              case 's':
                if (text[cursor++] === 'e') {
                  return 'case';
                }
                break;
              case 't':
                if (text.slice(cursor, cursor += 2) === 'ch') {
                  return 'catch';
                }
            }
            break;
          case 'l':
            if (text.slice(cursor, cursor += 3) === 'ass') {
              return 'class';
            }
            break;
          case 'o':
            if (text[cursor++] === 'n') {
              switch (text[cursor++]) {
                case 's':
                  if (text[cursor++] === 't') {
                    return 'const';
                  }
                  break;
                case 't':
                  if (text.slice(cursor, cursor += 4) === 'inue') {
                    return 'continue';
                  }
              }
            }
        }
        break;
      case 'd':
        switch (text[cursor++]) {
          case 'e':
            switch (text[cursor++]) {
              case 'b':
                if (text.slice(cursor, cursor += 5) === 'ugger') {
                  return 'debugger';
                }
                break;
              case 'f':
                if (text.slice(cursor, cursor += 4) === 'ault') {
                  return 'default';
                }
                break;
              case 'l':
                if (text.slice(cursor, cursor += 3) === 'ete') {
                  return 'delete';
                }
            }
            break;
          case 'o':
            return 'do';
        }
        break;
      case 'e':
        switch (text[cursor++]) {
          case 'l':
            if (text.slice(cursor, cursor += 2) === 'se') {
              return 'else';
            }
            break;
          case 'n':
            if (text.slice(cursor, cursor += 2) === 'um') {
              return 'enum';
            }
            break;
          case 'x':
            switch (text[cursor++]) {
              case 'p':
                if (text.slice(cursor, cursor += 3) === 'ort') {
                  return 'export';
                }
                break;
              case 't':
                if (text.slice(cursor, cursor += 4) === 'ends') {
                  return 'extends';
                }
            }
        }
        break;
      case 'f':
        switch (text[cursor++]) {
          case 'a':
            if (text.slice(cursor, cursor += 3) === 'lse') {
              return 'false';
            }
            break;
          case 'i':
            if (text.slice(cursor, cursor += 5) === 'nally') {
              return 'finally';
            }
            break;
          case 'o':
            if (text[cursor++] === 'r') {
              return 'for';
            }
            break;
          case 'u':
            if (text.slice(cursor, cursor += 5) === 'nction') {
              return 'function';
            }
        }
        break;
      case 'i':
        switch (text[cursor++]) {
          case 'f':
            return 'if';
          case 'm':
            switch (text[cursor++]) {
              case 'p':
                switch (text[cursor++]) {
                  case 'l':
                    if (text.slice(cursor, cursor += 6) === 'ements') {
                      return 'implements';
                    }
                    break;
                  case 'o':
                    if (text.slice(cursor, cursor += 2) === 'rt') {
                      return 'import';
                    }
                }
            }
            break;
          case 'n':
            switch (text[cursor++]) {
              case 's':
                if (text.slice(cursor, cursor += 7) === 'tanceof') {
                  return 'instanceof';
                }
                break;
              case 't':
                if (text.slice(cursor, cursor += 6) === 'erface') {
                  return 'interface';
                }
                break;
              default:
                cursor--;
                return 'in';
            }
        }
        break;
      case 'l':
        switch (text[cursor++]) {
          case 'e':
            if (text[cursor++] === 't') {
              return 'let';
            }
            break;
          case 'o':
            if (text.slice(cursor, cursor += 2) === 'op') {
              return 'loop';
            }
        }
        break;
      case 'n':
        switch (text[cursor++]) {
          case 'a':
            if (text.slice(cursor, cursor += 4) === 'tive') {
              return 'native';
            }
            break;
          case 'e':
            if (text[cursor++] === 'w') {
              return 'new';
            }
            break;
          case 'u':
            if (text.slice(cursor, cursor += 2) === 'll') {
              return 'null';
            }
        }
        break;
      case 'o':
        if (text[cursor++] === 'f') {
          return 'of';
        }
        break;
      case 'p':
        switch (text[cursor++]) {
          case 'a':
            if (text.slice(cursor, cursor += 5) === 'ckage') {
              return 'package';
            }
            break;
          case 'r':
            switch (text[cursor++]) {
              case 'i':
                if (text.slice(cursor, cursor += 4) === 'vate') {
                  return 'private';
                }
                break;
              case 'o':
                if (text.slice(cursor, cursor += 6) === 'tected') {
                  return 'protected';
                }
            }
            break;
          case 'u':
            if (text.slice(cursor, cursor += 4) === 'blic') {
              return 'blic';
            }
        }
        break;
      case 'r':
        if (text.slice(cursor, cursor += 5) === 'eturn') {
          return 'return';
        }
        break;
      case 's':
        switch (text[cursor++]) {
          case 't':
            if (text.slice(cursor, cursor += 4) === 'atic') {
              return 'static';
            }
            break;
          case 'u':
            if (text.slice(cursor, cursor += 3) === 'per') {
              return 'super';
            }
            break;
          case 'w':
            if (text.slice(cursor, cursor += 4) === 'itch') {
              return 'switch';
            }
        }
        break;
      case 't':
        switch (text[cursor++]) {
          case 'h':
            switch (text[cursor++]) {
              case 'e':
                if (text[cursor++] === 'n') {
                  return 'then';
                }
                break;
              case 'i':
                if (text[cursor++] === 's') {
                  return 'this';
                }
                break;
              case 'r':
                if (text.slice(cursor, cursor += 2) === 'ow') {
                  return 'throw';
                }
            }
            break;
          case 'r':
            switch (text[cursor++]) {
              case 'u':
                if (text[cursor++] === 'e') {
                  return 'true';
                }
                break;
              case 'y':
                return 'try';
            }
            break;
          case 'y':
            if (text.slice(cursor, cursor += 4) === 'peof') {
              return 'typeof';
            }
        }
        break;
      case 'u':
        switch (text[cursor++]) {
          case 'n':
            switch (text[cursor++]) {
              case 'd':
                if (text.slice(cursor, cursor += 6) === 'efined') {
                  return 'undefined';
                }
                break;
              case 'l':
                if (text.slice(cursor, cursor += 3) === 'ess') {
                  return 'unless';
                }
                break;
              case 't':
                if (text.slice(cursor, cursor += 2) === 'il') {
                  return 'until';
                }
            }
        }
        break;
      case 'v':
        switch (text[cursor++]) {
          case 'a':
            if (text[cursor++] === 'r') {
              return 'var';
            }
            break;
          case 'o':
            if (text.slice(cursor, cursor += 2) === 'id') {
              return 'void';
            }
        }
        break;
      case 'w':
        switch (text[cursor++]) {
          case 'h':
            switch (text[cursor++]) {
              case 'e':
                if (text[cursor++] === 'n') {
                  return 'when';
                }
                break;
              case 'i':
                if (text.slice(cursor, cursor += 3) === 'le') {
                  return 'while';
                }
            }
            break;
          case 'i':
            if (text.slice(cursor, cursor += 2) === 'th') {
              return 'with';
            }
        }
        break;
      case 'w':
        if (text.slice(cursor, cursor += 4) === 'ield') {
          return 'yield';
        }
    }
  };

  exports.Parser = Parser = (function() {
    function Parser() {}

    Parser.prototype.parse = function(code, options) {
      var oldCursor, oldIndentList, oldMemo, oldTabWidth, oldText, oldTextLength, oldTokens, oldyy, result;

      oldText = global.text;
      oldTextLength = global.textLength;
      oldCursor = global.cursor;
      oldTokens = global.tokens;
      oldMemo = global.memo;
      oldIndentList = global.indentList;
      oldTabWidth = global.tabWidth;
      oldyy = global.yy;
      global.text = code;
      global.textLength = code.length;
      global.cursor = 0;
      global.tokens = [];
      global.memo = {};
      global.indentList = [];
      global.tabWidth = 4;
      global.yy = this.yy;
      result = this.Root(0);
      if (oldText !== void 0) {
        global.text = oldText;
      }
      if (oldTextLength !== void 0) {
        global.textLength = oldTextLength;
      }
      if (oldCursor !== void 0) {
        global.cursor = oldCursor;
      }
      if (oldTokens !== void 0) {
        global.tokens = oldTokens;
      }
      if (oldMemo !== void 0) {
        global.memo = oldMemo;
      }
      if (oldIndentList !== void 0) {
        global.indentList = oldIndentList;
      }
      if (oldTabWidth !== void 0) {
        global.tabWidth = oldTabWidth;
      }
      if (oldyy !== void 0) {
        global.yy = oldyy;
      }
      return result;
    };

    Parser.prototype.Root = function(start) {
      var result;

      if (cursor === textLength) {
        return new yy.Block;
      }
      if (result = this.Body(start)) {
        return result;
      }
      result = this.Block(start);
      this.TERMINATOR(cursor);
      return result;
    };

    Parser.prototype.Body = function(start) {
      var lines, x;

      lines = [];
      x = this.Line(start);
      if (x) {
        lines.push(x);
      }
      while (1) {
        if (this.TERMINATOR(cursor)) {
          if (x = this.Line(cursor)) {
            lines.push(x);
          }
        } else {
          break;
        }
      }
      return yy.Block.wrap(lines);
    };

    Parser.prototype.Line = function(start) {
      return this.Statement(start) || this.Expression(start);
    };

    Parser.prototype.Statement = function(start) {
      switch (text[cursor]) {
        case 'r':
          return this.Return(start);
        case '#':
          return this.Comment(start);
        case 'b':
          return this.Break(start);
        case 'c':
          return this.Continue(start);
      }
    };

    Parser.prototype.Return = function(start) {
      var exp;

      if (literal('return')(start)) {
        if (exp = this.Expression(cursor)) {
          return new yy.Return(exp);
        } else {
          return new yy.Return;
        }
      }
    };

    Parser.prototype.Comment = function(start) {
      return this.HERECOMMENT(start);
    };

    Parser.prototype.Break = function(start) {
      return literal('break')(start);
    };

    Parser.prototype.Continue = function(start) {
      return literal('continue')(start);
    };

    Parser.prototype.Expression = function(start) {
      return this.Value(start) || this.Invocation(start) || this.Code(start) || this.Operation(start) || this.Assign(start) || this.If(start) || this.Try(start) || this.While(start) || this.For(start) || this.Switch(start) || this.Class(start) || this.Throw(start);
    };

    Parser.prototype.Block = function(start) {
      var body;

      if (this.INDENT(start)) {
        if (this.OUTDENT(cursor)) {
          return new yy.Block;
        } else if (body = this.Body(cursor) && this.OUTDENT(cursor)) {
          return body;
        }
      }
    };

    Parser.prototype.Identifier = function(start) {
      return this.IDENTIFIER(start);
    };

    Parser.prototype.Literal = function(start) {
      return this.NUMBER(start) || this.STRING(start) || this.JS(start) || this.REGEX(start) || this.DEBUGGER(start) || this.UNDEFINED(start) || this.NULL(start) || this.BOOL(start);
    };

    Parser.prototype.Assign = function(start) {
      var exp, left;

      if (left = this.Assignable(start) && wrap('=')(cursor)) {
        if (exp = this.Expression(cursor) || this.TERMINATOR(cursor) && (exp = this.Expression(cursor) || this.INDENT(cursor) && (exp = this.Expression && this.OUTDENT(cursor)))) {
          return new yy.Assign(left, exp);
        }
      }
    };

    Parser.prototype.AssignObj = function(start) {
      var exp, left, x;

      if (x = this.Comment) {
        return x;
      }
      if (left = this.ObjAssignable(start)) {
        if (wrap(':')) {
          if (exp = this.Expression(cursor) || this.INDENT(cursor) && (exp = this.Expression(cursor) && this.OUTDENT(cursor))) {
            return new yy.Assign(LOC(1)(new yy.Value(left)), exp, 'object');
          }
        } else {
          return new yy.Value(left);
        }
      }
    };

    Parser.prototype.ObjAssignable = function(start) {
      return this.Identifier(start) || this.Number(start) || this.String(start) || this.ThisProperty(start);
    };

    Parser.prototype.Code = function(start) {
      var body, funcGlyph, params;

      if (this.PARAM_START(start) && (params = this.ParamList(cursor) && this.PARAM_END(cursor) && (funcGlyph = this.FuncGlyph(cursor) && (body = this.Block(cursor))))) {
        return new yy.Code(params, body, funcGlyph);
      } else if (funcGlyph = this.FuncGlyph(cursor) && (body = this.Block(cursor))) {
        return new yy.Code([], body, funcGlyph);
      }
    };

    Parser.prototype.FuncGlyph = function(start) {
      if (wrap('->')(start)) {
        return 'func';
      } else if (wrap('=>')) {
        return 'boundfunc';
      }
    };

    Parser.prototype.OptComma = function(start) {
      spaces(start);
      if (char(',')) {
        spaces(cursor);
        [true];
      }
      return [false];
    };

    Parser.prototype.ParamList = function(start) {
      var meetComma, p, param, params, result, _j, _len1;

      if (param = this.Param(start)) {
        result = [param];
        while (1) {
          meetComma = this.OptComma(cursor);
          if (this.TERMINATOR(cursor) && (param = this.Param(cursor))) {
            result.push(param);
          } else if (this.INDENT(cursor)) {
            params = this.ParamList(cursor);
            for (_j = 0, _len1 = params.length; _j < _len1; _j++) {
              p = params[_j];
              result.push(p);
            }
            this.OUTDENT(cursor);
          } else if (meetComma[0] && (param = this.Param(cursor))) {
            result.push(param);
          } else {
            break;
          }
        }
        return result;
      }
    };

    Parser.prototype.Param = function(start) {
      var exp, v;

      v = this.ParamVar(start);
      if (wrap('...')(cursor)) {
        return new yy.Param(v, null, true);
      } else if (wrap('=')(cursor) && (exp = this.Expression(cursor))) {
        return new yy.Param(v, exp);
      } else {
        return new yy.Param(v);
      }
    };

    Parser.prototype.ParamVar = function(start) {
      return this.Identifier(start) || this.ThisProperty(start) || this.Array(start) || this.Object(start);
    };

    Parser.prototype.Splat = function(start) {
      var exp;

      if (exp = this.Expression(start) && wrap('...')(cursor)) {
        return new yy.Splat(exp);
      }
    };

    Parser.prototype.SimpleAssignable = function(start) {
      var accessor, caller, name, thisProp, value;

      if (name = this.Identifier(start)) {
        return new yy.Value(name);
      } else if (value = this.Value(start) && (accessor = this.Accessor(cursor))) {
        return value.add(accessor);
      } else if (caller = this.Invocation(start) && (accessor = this.Accessor(cursor))) {
        return new yy.Value(caller, [].concat(accessor));
      } else if (thisProp = this.ThisProperty(start)) {
        return thisProp;
      }
    };

    Parser.prototype.Assignable = function(start) {
      return this.SimpleAssignable(start) || this.newyyValue(this.Array)(start) || this.newyyValue(this.Object)(start);
    };

    Parser.prototype.Value = function(start) {
      return this.Assignable(start) || this.newyyValue(this.Literal)(start) || this.newyyValue(this.Parenthetical)(start) || this.newyyValue(this.Range)(start) || this.This(start);
    };

    Parser.prototype.Accessor = function(start) {
      var id, index;

      if (wrap('.') && (id = this.Identifier(cursor))) {
        return new yy.Access(id);
      } else if (wrap('?.') && (id = this.Identifier(cursor))) {
        return new yy.Access(id, 'soak');
      } else if (wrap('::') && (id = this.Identifier(cursor))) {
        return new [LOC(1)(new yy.Access(new yy.Literal('prototype'))), LOC(2)(new yy.Access(id))];
      } else if (wrap('?::') && (id = this.Identifier(cursor))) {
        return [LOC(1)(new yy.Access(new yy.Literal('prototype'), 'soak')), LOC(2)(new yy.Access(id))];
      } else if (wrap('::')) {
        return new Access(new Literal('prototype'));
      } else if (index = this.Index(start)) {
        return index;
      }
    };

    Parser.prototype.Index = function(start) {
      var val;

      if (this.INDEX_START(start) && (val = this.IndexValue(cursor) && this.INDEX_END(cursor))) {
        val;
      }
      if (this.INDEX_SOAK(cursor) && this.Index(cursor)) {
        return yy.extend($2, {
          soak: true
        });
      }
    };

    Parser.prototype.IndexValue = function(start) {
      var slice, value;

      if (value = this.Expression(start)) {
        return new yy.Index(value);
      } else if (slice = this.Slice(start)) {
        return new yy.Slice(slice);
      }
    };

    Parser.prototype.Object = function(start) {
      var assigns, leftBrace;

      if (leftBrace = wrap('{')(start)) {
        spaces(cursor);
        if (char('}')) {
          return new yy.Obj([], leftBrace.generated);
        } else if (assigns = this.AssignList(cursor) && this.OptComma(cursor) && wrap('}')(cursor)) {
          return new yy.Obj(assigns, leftBrace.generated);
        }
      }
    };

    Parser.prototype.AssignList = function(start) {
      var assign, assigns, meetComma, result, x, _j, _len1;

      if (assign = this.AssignObj(start)) {
        result = [assign];
        while (1) {
          meetComma = this.OptComma(cursor);
          if (this.TERMINATOR(cursor) && (assign = this.AssignObj(cursor))) {
            result.push(assign);
          } else if (this.INDENT(cursor)) {
            assigns = this.AssignList(cursor);
            for (_j = 0, _len1 = assigns.length; _j < _len1; _j++) {
              x = assigns[_j];
              result.push(x);
            }
            this.OUTDENT(cursor);
          } else if (meetComma[0] && (assign = this.AssignObj(cursor))) {
            result.push(param);
          } else {
            break;
          }
        }
        return result;
      }
    };

    Parser.prototype.Class = function(start) {
      var body, name, sup;

      if (this.CLASS(start)) {
        if (name = this.SimpleAssignable(cursor)) {
          if (this.EXTENDS(cursor) && (sup = this.Expression(cursor))) {
            if (body = this.Block(cursor)) {
              return new yy.Class(name, sup, body);
            } else {
              return new yy.Class(name, sup);
            }
          } else if (body = this.Block(cursor)) {
            return new yy.Class(name, null, body);
          } else {
            return new yy.Class(name);
          }
        } else {
          if (this.EXTENDS(cursor) && (sup = this.Expression(cursor))) {
            if (body = this.Block(cursor)) {
              return new yy.Class(null, sup, body);
            } else {
              return new yy.Class(null, sup);
            }
          } else if (body = this.Block(cursor)) {
            return new yy.Class(null, null, body);
          } else {
            return new yy.Class;
          }
        }
      }
    };

    Parser.prototype.Invocation = function(start) {
      if (this.Value(start) && this.OptFuncExist(cursor) && this.Arguments(cursor)) {
        return new yy.Call($1, $3, $2);
      } else if (this.Invocation(start) && this.OptFuncExist(cursor) && this.Arguments(cursor)) {
        return new yy.Call($1, $3, $2);
      } else if (this.SUPER(start)) {
        return new yy.Call('super', [new yy.Splat(new yy.Literal('arguments'))]);
      } else if (this.SUPER(start) && this.Arguments(cursor)) {
        return new yy.Call('super', $2);
      }
    };

    Parser.prototype.OptFuncExist = function(start) {
      if (emptyword(start)) {
        false;
      }
      if (this.FUNC_EXIST(start)) {
        return true;
      }
    };

    Parser.prototype.Arguments = function(start) {
      var args, result;

      if (this.CALL_START(start)) {
        if (args = this.ArgList(cursor) && this.OptComma(cursor)) {
          args;
        } else {
          result = [];
        }
        if (this.CALL_END(cursor)) {
          return result;
        }
      }
    };

    Parser.prototype.This = function(start) {
      if (this.THIS(start)) {
        new yy.Value(new yy.Literal('this'));
      }
      if (wrap('@')(start)) {
        return new yy.Value(new yy.Literal('this'));
      }
    };

    Parser.prototype.ThisProperty = function(start) {
      if (wrap('@')(start) && Identifier(cursor)) {
        return new yy.Value(LOC(1)(new yy.Literal('this')), [LOC(2)(new yy.Access($2))], 'this');
      }
    };

    Parser.prototype.Array = function(start) {
      var result;

      if (wrap('[')(start)) {
        if (this.ArgList(cursor) && this.OptComma(cursor)) {
          result = new yy.Arr($2);
        } else {
          result = new yy.Arr([]);
        }
        if (wrap(']')(cursor)) {
          return result;
        }
      }
    };

    Parser.prototype.RangeDots = function(start) {
      if (wrap('..')(start)) {
        return 'inclusive';
      } else if (wrap('...')(start)) {
        return 'exclusive';
      }
    };

    Parser.prototype.Range = function(start) {
      if (wrap('[')(start) && this.Expression(cursor) && this.RangeDots(cursor) && this.Expression(cursor)(wrap(']'))) {
        return new yy.Range($2, $4, $3);
      }
    };

    Parser.prototype.Slice = function(start) {
      if (this.Expression(start) && this.RangeDots(cursor) && this.Expression(cursor)) {
        new yy.Range($1, $3, $2);
      }
      if (this.Expression(start) && this.RangeDots(cursor)) {
        new yy.Range($1, null, $2);
      }
      if (this.RangeDots(start) && this.Expression(cursor)) {
        new yy.Range(null, $2, $1);
      }
      if (this.RangeDots(start)) {
        return new yy.Range(null, null, $1);
      }
    };

    Parser.prototype.ArgList = function(start) {
      if (this.Arg(start)) {
        return [$1];
      } else if (this.ArgList(start) && wrap(',') && this.Arg(cursor)) {
        return $1.concat($3);
      } else if (this.ArgList(start) && this.OptComma(cursor) && this.TERMINATOR(cursor) && this.Arg(cursor)) {
        return $1.concat($4);
      } else if (this.INDENT(start) && this.ArgList(cursor) && this.OptComma(cursor) && this.OUTDENT(cursor)) {
        return $2;
      } else if (this.ArgList(start) && this.OptComma(cursor) && this.INDENT(cursor) && this.ArgList(cursor) && this.OptComma(cursor) && this.OUTDENT(cursor)) {
        return $1.concat($4);
      }
    };

    Parser.prototype.Arg = function(start) {
      return this.Expression(start) || this.Splat(start);
    };

    Parser.prototype.SimpleArgs = function(start) {
      var exp, result;

      if (exp = this.Expression(start)) {
        result = [exp];
        while (1) {
          if (wrap(',')) {
            if (exp = this.Expression(cursor)) {
              result.push(exp);
            } else {
              return;
            }
          }
        }
        return result;
      }
    };

    Parser.prototype.Try = function(start) {
      var catch_, final, test;

      test = this.TRY(start) && this.Block(cursor);
      if (test) {
        if (this.Catch(cursor) && (catch_ = this.Block(cursor))) {
          if (this.FINALLY(cursor) && (final = this.Block(cursor))) {
            return new yy.Try(test, catch_[0], catch_[1], final);
          } else {
            return new yy.Try(test, catch_[0], catch_[1]);
          }
        } else if (this.FINALLY(cursor) && (final = this.Block(cursor))) {
          return new yy.Try(test, null, null, final);
        } else {
          return new yy.Try(test);
        }
      }
    };

    Parser.prototype.Catch = function(start) {
      var body, obj, vari;

      if (this.CATCH(start)) {
        if (vari = this.Identifier(cursor) && (body = this.Block(cursor))) {
          [vari, body];
        }
        if (obj = this.Object(cursor)) {
          if (body = this.Block(cursor)) {
            return [LOC(2)(new yy.Value(obj)), body];
          }
        } else if (body = this.Block(cursor)) {
          return [null, body];
        }
      }
    };

    Parser.prototype.Throw = function(start) {
      if (this.THROW(start) && this.Expression(cursor)) {
        return new yy.Throw($2);
      }
    };

    Parser.prototype.Parenthetical = function(start) {
      var body;

      if (wrap('(')(start)) {
        if (body = this.Body(start)) {
          if (wrap(')')(cursor)) {
            new yy.Parens(body);
          }
        }
        if (this.INDENT(start) && this.Body(cursor) && this.OUTDENT(cursor)) {
          if (wrap(')')(cursor)) {
            return new yy.Parens($3);
          }
        }
      }
    };

    Parser.prototype.WhileSource = function(start) {
      var test, value;

      if (this.WHILE(start)) {
        if (test = Expression(cursor)) {
          if (this.WHEN(cursor) && (value = this.Expression(cursor))) {
            return new yy.While(test, {
              guard: value
            });
          } else {
            return new yy.While($2);
          }
        }
      } else if (this.UNTIL(start)) {
        if (test = Expression(cursor)) {
          if (this.WHEN(cursor) && (value = this.Expression(cursor))) {
            return new yy.While($2, {
              invert: true,
              guard: $4
            });
          } else {
            return new yy.While($2, {
              invert: true
            });
          }
        }
      }
    };

    Parser.prototype.While = function(start) {
      var body;

      if (this.WhileSource(start) && this.Block(cursor)) {
        return $1.addBody($2);
      } else if (this.Statement(start) && this.WhileSource(cursor)) {
        return $2.addBody(LOC(1)(yy.Block.wrap([$1])));
      } else if (this.Expression(start) && this.WhileSource(cursor)) {
        return $2.addBody(LOC(1)(yy.Block.wrap([$1])));
      } else if (body = this.Loop(start)) {
        return body;
      }
    };

    Parser.prototype.Loop = function(start) {
      var body;

      if (this.LOOP(start)) {
        if (body = this.Block(cursor)) {
          return new yy.While(LOC(1)(new yy.Literal('true'))).addBody(body);
        } else if (body = this.Expression(cursor)) {
          return new yy.While(LOC(1)(new yy.Literal('true'))).addBody(LOC(2)(Block.wrap([body])));
        }
      }
    };

    Parser.prototype.For = function(start) {
      var action, test;

      if (action = this.Statement(start) && (test = this.ForBody(cursor))) {
        return new yy.For(action, test);
      } else if (action = this.Expression(start) && (test = this.ForBody(cursor))) {
        return new yy.For(action, test);
      } else if (test = this.ForBody(start) && (action = this.Block(cursor))) {
        return new yy.For(action, test);
      }
    };

    Parser.prototype.ForBody = function(start) {
      var range, src;

      if (range = this.FOR(start) && this.Range(cursor)) {
        return {
          source: LOC(2)(new yy.Value(range))
        };
      } else if (start = this.ForStart(start) && (src = this.ForSource(cursor))) {
        src.own = start.own;
        src.name = start[0];
        src.index = start[1];
        return src;
      }
    };

    Parser.prototype.ForStart = function(start) {
      var vari;

      if (this.FOR(start)) {
        if (this.OWN(cursor)) {
          if (vari = this.ForVariables(cursor)) {
            vari.own = true;
            return vari;
          }
        } else if (vari = this.ForVariables(cursor)) {
          return vari;
        }
      }
    };

    Parser.prototype.ForValue = function(start) {
      var id, obj, prop;

      if (id = this.Identifier(start)) {
        return id;
      } else if (prop = this.ThisProperty(start)) {
        return prop;
      } else if (this.Array(start)) {
        return new yy.Value(arr);
      } else if (obj = this.Object(start)) {
        return new yy.Value(obj);
      }
    };

    Parser.prototype.ForVariables = function(start) {
      var v, v3;

      if (v = this.ForValue(start)) {
        if (wrap(',')(cursor) && (v3 = this.ForValue(cursor))) {
          return [v1, v3];
        } else {
          return [v];
        }
      }
    };

    Parser.prototype.ForSource = function(start) {
      var guard, source, step;

      if (this.FORIN(start) && (source = this.Expression(cursor))) {
        if (this.WHEN(cursor) && (guard = this.Expression(cursor))) {
          if (this.BY(cursor) && (step = this.Expression(cursor))) {
            ({
              source: source,
              guard: guard,
              step: step
            });
          } else {
            ({
              source: source,
              guard: guard,
              object: true
            });
          }
        } else {
          ({
            source: source
          });
        }
      }
      if (this.FOROF(start) && (source = this.Expression(cursor))) {
        if (this.WHEN(cursor) && (guard = this.Expression(cursor))) {
          if (this.BY(cursor) && (step = this.Expression(cursor))) {
            return {
              source: source,
              guard: guard,
              step: step
            };
          } else {
            return {
              source: source,
              guard: guard,
              object: true
            };
          }
        } else {
          return {
            source: source
          };
        }
      }
    };

    Parser.prototype.Switch = function(start) {
      var test, whens;

      if (this.SWITCH(start)) {
        if (this.INDENT(cursor)) {
          if (whens = this.Whens(cursor)) {
            if (this.ELSE(cursor)(Block(cursor)(new yy.Switch(null, whens, else_)))) {

            } else {
              new yy.Switch(test, whens);
            }
          }
          OUTDENT(cursor);
        } else if (test = this.Expression(cursor)) {
          if (this.INDENT(cursor)) {
            if (whens = this.Whens(cursor)) {
              if (this.ELSE(cursor) && this.Block(cursor)(new yy.Switch(null, whens, else_))) {

              } else {
                new yy.Switch(test, whens);
              }
            }
          }
        }
        return this.OUTDENT(cursor);
      }
    };

    Parser.prototype.Whens = function(start) {
      var action, args, result;

      result = [];
      while (1) {
        if (this.LEADING_WHEN(start)) {
          if (args = this.SimpleArgs(cursor) && (action = this.Block(cursor) && may(this.TERMINATOR)(cursor))) {
            result.push([args, action]);
          } else {
            return result;
          }
        }
      }
    };

    Parser.prototype.IfBlock = function(start) {
      var body, test;

      if (this.IF(start) && (test = this.Expression(cursor) && (body = Block(cursor)))) {
        new yy.If(test, body, {
          type: $1
        });
      }
      if (this.IfBlock(start) && this.ELSE(cursor) && this.IF(cursor) && this.Expression(cursor) && Block(cursor)) {
        return $1.addElse(new yy.If($4, $5, {
          type: $3
        }));
      }
    };

    Parser.prototype.If = function(start) {
      var elseBody, if_;

      if (if_ = this.IfBlock(start)) {
        if (this.ELSE(cursor) && (elseBody = this.Block(cursor))) {
          if_.addElse(elseBody);
        } else {
          if_;
        }
      }
      if (this.Statement(start) && this.POST_IF(cursor) && this.Expression(cursor)) {
        return new yy.If($3, LOC(1)(Block.wrap([$1])), {
          type: $2,
          statement: true
        });
      }
    };

    Parser.prototype.Operation = function(start) {
      var exp, op;

      if (op = this.UNARY(start) && (exp = this.Expression(cursor))) {
        return new yy.Op(op, exp);
      } else if (wrap('-')(start) && (exp = this.Expression(cursor))) {
        return new yy.Op('-', exp, {
          prec: 'UNARY'
        });
      } else if (wrap('+')(start) && (exp = this.Expression(cursor))) {
        return new yy.Op('+', exp, {
          prec: 'UNARY'
        });
      } else if (wrap('--')(start) && this.SimpleAssignable(cursor)) {
        return new yy.Op('--', $2);
      } else if (wrap('++')(start) && this.SimpleAssignable(cursor)) {
        return new yy.Op('++', $2);
      } else if (this.SimpleAssignable(start) && wrap('--')(cursor)) {
        return new yy.Op('--', $1, null, true);
      } else if (this.SimpleAssignable(start) && wrap('++')(cursor)) {
        return new yy.Op('++', $1, null, true);
      } else if (this.Expression(start) && wrap('?')(cursor)) {
        return new yy.Existence($1);
      } else if (this.Expression(start) && wrap('+')(cursor) && this.Expression(cursor)) {
        return new yy.Op('+', $1, $3);
      } else if (this.Expression(start) && -cursor && this.Expression(cursor)) {
        return new yy.Op('-', $1, $3);
      } else if (this.Expression(start) && this.MATH(cursor) && this.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (this.Expression(start) && SHIFT(cursor) && this.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (this.Expression(start) && this.COMPARE(cursor) && this.Expression) {
        return new yy.Op($2, $1, $3);
      } else if (this.Expression(start) && this.LOGIC(cursor) && this.Expression(cursor)) {
        return new yy.Op($2, $1, $3);
      } else if (this.Expression(start) && this.RELATION(cursor) && this.Expression(cursor)) {
        if ($2.charAt(0) === '!') {
          return new yy.Op($2.slice(1), $1, $3).invert();
        } else {
          return new yy.Op($2, $1, $3);
        }
      } else if (this.SimpleAssignable(start) && this.COMPOUND_ASSIGN(cursor)) {

      } else if (this.Expression(cursor)) {
        return new yy.Assign($1, $3, $2);
      } else if (this.SimpleAssignable(start) && this.COMPOUND_ASSIGN(cursor)) {

      } else if (this.INDENT(cursor) && this.Expression(cursor) && this.OUTDENT(cursor)) {
        return new yy.Assign($1, $4, $2);
      } else if (this.SimpleAssignable(start) && this.COMPOUND_ASSIGN(cursor) && this.TERMINATOR(cursor)) {

      } else if (this.Expression(cursor)) {
        return new yy.Assign($1, $4, $2);
      } else if (this.SimpleAssignable(start) && this.EXTENDS(cursor) && this.Expression(cursor)) {
        return new yy.Extends($1, $3);
      } else if (this.Expression(start) && this.POST_IF(cursor) && this.Expression(cursor)) {
        return new yy.If($3, LOC(1)(Block.wrap([$1])), {
          type: $2,
          statement: true
        });
      }
    };

    Parser.prototype.newyyValue = function(item) {
      return function(start) {
        var x;

        if (x = item(start)) {
          return new yy.Value(x);
        }
      };
    };

    Parser.prototype.TERMINATOR = function(start) {
      return wrap(';');
    };

    Parser.prototype.STATEMENT = function(start) {
      ({
        x: wrap(orp('break', 'continue'))
      });
      if (x) {
        return new yy.Literal(x);
      }
    };

    Parser.prototype.IDENTIFIER = function(start) {
      var id;

      if (id = identifier(start)) {
        return new yy.Literal(id);
      }
    };

    Parser.prototype.NUMBER = function(start) {
      return new yy.Literal($1);
    };

    Parser.prototype.STRING = function(start) {
      return new yy.Literal($1);
    };

    Parser.prototype.JS = function(start) {
      return new yy.Literal($1);
    };

    Parser.prototype.REGEX = function(start) {
      return new yy.Literal($1);
    };

    Parser.prototype.DEBUGGER = function(start) {
      return new yy.Literal($1);
    };

    Parser.prototype.UNDEFINED = function(start) {
      return new yy.Undefined;
    };

    Parser.prototype.NULL = function(start) {
      return new yy.Null;
    };

    Parser.prototype.BOOL = function(start) {
      return new yy.Bool($1);
    };

    Parser.prototype.HERECOMMENT = function(start) {
      return new yy.Comment($1);
    };

    return Parser;

  })();

  operators = [['left', '.', '?.', '::', '?::'], ['left', 'CALL_START', 'CALL_END'], ['nonassoc', '++', '--'], ['left', '?'], ['right', 'UNARY'], ['left', 'MATH'], ['left', '+', '-'], ['left', 'SHIFT'], ['left', 'RELATION'], ['left', 'COMPARE'], ['left', 'LOGIC'], ['nonassoc', 'INDENT', 'OUTDENT'], ['right', '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS'], ['right', 'FORIN', 'FOROF', 'BY', 'WHEN'], ['right', 'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS'], ['right', 'POST_IF']];

  exports.parser = new Parser({
    operators: operators.reverse()
  });

}).call(this);

/*
//@ sourceMappingURL=parser.map
*/
